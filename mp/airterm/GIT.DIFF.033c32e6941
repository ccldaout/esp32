diff --git a/ports/esp32/Makefile b/ports/esp32/Makefile
index d2d6192b..823e7c83 100644
--- a/ports/esp32/Makefile
+++ b/ports/esp32/Makefile
@@ -14,8 +14,8 @@ FROZEN_MPY_DIR = modules
 # include py core make definitions
 include $(TOP)/py/py.mk
 
-PORT ?= /dev/ttyUSB0
-BAUD ?= 460800
+PORT ?= /dev/ttyS2
+BAUD ?= 115200
 FLASH_MODE ?= dio
 FLASH_FREQ ?= 40m
 FLASH_SIZE ?= 4MB
@@ -132,6 +132,7 @@ SRC_C = \
 	uart.c \
 	gccollect.c \
 	mphalport.c \
+	airterm.c \
 	fatfs_port.c \
 	help.c \
 	modutime.c \
diff --git a/ports/esp32/airterm.c b/ports/esp32/airterm.c
new file mode 100644
index 00000000..120701da
--- /dev/null
+++ b/ports/esp32/airterm.c
@@ -0,0 +1,202 @@
+/*
+ * This file is part of the MicroPython project, http://micropython.org/
+ *
+ * Development of the code in this file was sponsored by Microbric Pty Ltd
+ *
+ * The MIT License (MIT)
+ *
+ * Copyright (c) 2014 Damien P. George
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "freertos/FreeRTOS.h"
+#include "freertos/semphr.h"
+#include "esp_timer.h"
+#include "lwip/sockets.h"
+#include "mphalport_add.h"
+
+#define BUFSIZE_b 128
+
+typedef struct _airterm_t {
+    int socket;
+    esp_timer_handle_t timer;
+    uint32_t s_size;
+    char s_buff[BUFSIZE_b];
+    char t_buff[BUFSIZE_b];
+} _airterm_t;
+
+STATIC _airterm_t *aterm;
+STATIC SemaphoreHandle_t aterm_mutex;
+
+
+STATIC void _debug(const char *s)
+{
+    mp_hal_stdout_tx_strn_x(s, strlen(s), false);
+    mp_hal_stdout_tx_strn_x("\r\n", 2, false);
+}
+
+
+STATIC void _airterm_recv(int socket)
+{
+    char buf[64];
+
+    int n = lwip_recv(socket, buf, sizeof(buf), MSG_DONTWAIT);
+    if (n > 0) {
+	mp_hal_stdin_rx_insert(buf, n);
+    } else {
+	if (n == 0 || errno != EWOULDBLOCK) {
+	    mp_airterm_unregister();
+	}
+    }
+}
+
+STATIC void _airterm_send(int socket, const char *data, uint32_t size)
+{
+    while (size > 0) {
+	int n = lwip_send(socket, data, size, 0);
+	if (n < 0) {
+	    mp_airterm_unregister();
+	    return;
+	}
+	data += n;
+	size -= n;
+    }
+}
+
+STATIC void _airterm_flush(void)
+{
+    char *data1;
+    uint32_t size1;
+    int socket;
+
+    (void)xSemaphoreTake(aterm_mutex, portTICK_PERIOD_MS);
+    if (aterm == 0) {
+	xSemaphoreGive(aterm_mutex);
+	return;
+    }
+    data1 = aterm->t_buff;
+    size1 = aterm->s_size;
+    if (size1 != 0) {
+	(void)memcpy(data1, aterm->s_buff, size1);
+	aterm->s_size = 0;
+	socket = aterm->socket;
+    }
+    xSemaphoreGive(aterm_mutex);
+
+    if (size1 != 0)
+	_airterm_send(socket, data1, size1);
+}
+
+STATIC void mp_airterm_push(const char *data2, uint32_t size2)
+{
+    char *data1;
+    uint32_t size1;
+    int socket;
+
+    if (aterm == 0)
+	return;
+
+    (void)xSemaphoreTake(aterm_mutex, portTICK_PERIOD_MS);
+    if (aterm == 0) {
+	xSemaphoreGive(aterm_mutex);
+	return;
+    }
+    data1 = aterm->t_buff;
+    if (aterm->s_size + size2 > BUFSIZE_b) {
+	uint32_t shift2 = BUFSIZE_b - aterm->s_size;
+	(void)memcpy(data1, aterm->s_buff, aterm->s_size);
+	(void)memcpy(data1+aterm->s_size, data2, shift2);
+	aterm->s_size = size2 - shift2;
+	(void)memcpy(aterm->s_buff, data2+shift2, aterm->s_size);
+	size1 = BUFSIZE_b;
+	socket = aterm->socket;
+    } else {
+	(void)memcpy(aterm->s_buff+aterm->s_size, data2, size2);
+	aterm->s_size += size2;
+	size1 = 0;
+    }
+    xSemaphoreGive(aterm_mutex);
+
+    if (size1 != 0)
+	_airterm_send(socket, data1, size1);
+}
+
+STATIC void mp_airterm_transmit(void *__void)
+{
+    if (aterm != 0) {
+	int socket = aterm->socket;
+	_airterm_flush();
+	_airterm_recv(socket);
+    }
+}
+
+bool mp_airterm_register(int socket)
+{
+    if (aterm != 0)
+	return false;
+
+    if ((aterm = malloc(sizeof(*aterm))) == 0)
+	return false;
+
+    if (aterm_mutex == 0)
+	aterm_mutex = xSemaphoreCreateMutex();	/* lock */
+
+    aterm->socket = socket;
+    aterm->s_size = 0;
+
+    int enable = 1;
+    lwip_setsockopt(socket, IPPROTO_TCP, TCP_NODELAY, &enable, sizeof(enable));
+
+    esp_timer_create_args_t args = {
+	.callback = mp_airterm_transmit,
+	.arg = 0,
+	.dispatch_method = ESP_TIMER_TASK,
+	.name = "airterm",
+    };
+    esp_timer_create(&args, &aterm->timer);
+    esp_timer_start_periodic(aterm->timer, 50*1000);
+
+    mp_hal_set_stdout_forwarder(mp_airterm_push);
+
+    xSemaphoreGive(aterm_mutex);		/* unlock */
+    return true;
+}
+
+void mp_airterm_unregister(void)
+{
+    if (aterm != 0) {
+	(void)xSemaphoreTake(aterm_mutex, portTICK_PERIOD_MS);
+	if (aterm) {
+	    esp_timer_stop(aterm->timer);
+	    esp_timer_delete(aterm->timer);
+	    mp_hal_set_stdout_forwarder(0);
+	    if (aterm->socket != -1)
+		lwip_close(aterm->socket);
+	    aterm->socket = -1;
+	    free(aterm);
+	    aterm = 0;
+	}
+	xSemaphoreGive(aterm_mutex);
+    }
+}
diff --git a/ports/esp32/modsocket.c b/ports/esp32/modsocket.c
index 31d15396..5beccbcf 100644
--- a/ports/esp32/modsocket.c
+++ b/ports/esp32/modsocket.c
@@ -54,6 +54,8 @@
 #include "lwip/igmp.h"
 #include "esp_log.h"
 
+#include "mphalport_add.h"
+
 #define SOCKET_POLL_US (100000)
 
 typedef struct _socket_obj_t {
@@ -567,6 +569,19 @@ STATIC mp_obj_t esp_socket_initialize() {
 }
 STATIC MP_DEFINE_CONST_FUN_OBJ_0(esp_socket_initialize_obj, esp_socket_initialize);
 
+STATIC mp_obj_t socket_airterm(mp_obj_t arg) {
+    bool ret = true;
+    if (arg == mp_const_none) {
+	mp_airterm_unregister();
+    } else {
+	socket_obj_t *sock = MP_OBJ_TO_PTR(arg);
+	ret = mp_airterm_register(sock->fd);
+	sock->fd = -1;
+    }
+    return ret ? mp_const_true : mp_const_false;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(socket_airterm_obj, socket_airterm);
+
 STATIC const mp_map_elem_t mp_module_socket_globals_table[] = {
     { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_usocket) },
     { MP_OBJ_NEW_QSTR(MP_QSTR___init__), (mp_obj_t)&esp_socket_initialize_obj },
@@ -584,6 +599,7 @@ STATIC const mp_map_elem_t mp_module_socket_globals_table[] = {
     { MP_OBJ_NEW_QSTR(MP_QSTR_SOL_SOCKET), MP_OBJ_NEW_SMALL_INT(SOL_SOCKET) },
     { MP_OBJ_NEW_QSTR(MP_QSTR_SO_REUSEADDR), MP_OBJ_NEW_SMALL_INT(SO_REUSEADDR) },
     { MP_OBJ_NEW_QSTR(MP_QSTR_IP_ADD_MEMBERSHIP), MP_OBJ_NEW_SMALL_INT(IP_ADD_MEMBERSHIP) },
+    { MP_ROM_QSTR(MP_QSTR_airterm), (mp_obj_t)&socket_airterm_obj },
 };
 
 STATIC MP_DEFINE_CONST_DICT(mp_module_socket_globals, mp_module_socket_globals_table);
diff --git a/ports/esp32/mphalport.c b/ports/esp32/mphalport.c
index e588fc65..21bfaebd 100644
--- a/ports/esp32/mphalport.c
+++ b/ports/esp32/mphalport.c
@@ -27,24 +27,69 @@
  */
 
 #include <stdio.h>
+#include <string.h>
 #include <sys/time.h>
 
 #include "freertos/FreeRTOS.h"
 #include "freertos/task.h"
 #include "rom/uart.h"
 
-#include "py/obj.h"
 #include "py/mpstate.h"
 #include "py/mphal.h"
 #include "extmod/misc.h"
 #include "lib/utils/pyexec.h"
 
+#include "driver/uart.h"
+#include "mphalport_add.h"
+#include "freertos/semphr.h"
+#include "py/runtime.h"
+
 STATIC uint8_t stdin_ringbuf_array[256];
 ringbuf_t stdin_ringbuf = {stdin_ringbuf_array, sizeof(stdin_ringbuf_array)};
 
+static void (*stdout_forwarder)(const char *data, uint32_t len);
+STATIC SemaphoreHandle_t mutex_handle;
+
+void mp_hal_set_stdout_forwarder(void (*forwarder)(const char *, uint32_t))
+{
+    if (mutex_handle == 0) {
+	mutex_handle = xSemaphoreCreateMutex();
+	if (mutex_handle)
+	    xSemaphoreGive(mutex_handle);
+    }
+    stdout_forwarder = forwarder;
+}
+
+STATIC inline void sem_lock(void)
+{
+    if (mutex_handle) {
+	(void)xSemaphoreTake(mutex_handle, portTICK_PERIOD_MS);
+    }
+}
+
+STATIC inline void sem_unlock(void)
+{
+    if (mutex_handle) {
+	xSemaphoreGive(mutex_handle);
+    }
+}
+
+void mp_hal_stdin_rx_insert(const char *data, mp_uint_t size)	/* NEW */
+{
+    uart_disable_rx_intr(UART_NUM_0);
+    sem_lock();
+    for (; size; data++, size--) {
+	ringbuf_put(&stdin_ringbuf, *data);
+    }
+    sem_unlock();
+    uart_enable_rx_intr(UART_NUM_0);
+}
+
 int mp_hal_stdin_rx_chr(void) {
     for (;;) {
+	sem_lock();
         int c = ringbuf_get(&stdin_ringbuf);
+	sem_unlock();
         if (c != -1) {
             return c;
         }
@@ -53,38 +98,89 @@ int mp_hal_stdin_rx_chr(void) {
     }
 }
 
+STATIC void call_stdout_forwarder(const char *str, uint32_t len)
+{
+    void (*forwarder)(const char *, uint32_t) = stdout_forwarder;
+    if (forwarder != 0) {
+	forwarder(str, len);
+    }
+}
+
 void mp_hal_stdout_tx_char(char c) {
     uart_tx_one_char(c);
     //mp_uos_dupterm_tx_strn(&c, 1);
 }
 
-void mp_hal_stdout_tx_str(const char *str) {
+void mp_hal_stdout_tx_str_x(const char *str, bool forward) {
+    const char * const s = str;
+    uint32_t n = strlen(s);
     MP_THREAD_GIL_EXIT();
     while (*str) {
         mp_hal_stdout_tx_char(*str++);
     }
+    if (forward)
+	call_stdout_forwarder(s, n);
     MP_THREAD_GIL_ENTER();
 }
 
-void mp_hal_stdout_tx_strn(const char *str, uint32_t len) {
+void mp_hal_stdout_tx_strn_x(const char *str, uint32_t len, bool forward) {
+    const char * const s = str;
+    const uint32_t n = len;
     MP_THREAD_GIL_EXIT();
     while (len--) {
         mp_hal_stdout_tx_char(*str++);
     }
+    if (forward)
+	call_stdout_forwarder(s, n);
     MP_THREAD_GIL_ENTER();
 }
 
-void mp_hal_stdout_tx_strn_cooked(const char *str, uint32_t len) {
+void mp_hal_stdout_tx_strn_cooked_x(const char *str, uint32_t len, bool forward) {
+    char buff[64];
+    char *p, *e = &buff[sizeof(buff)];
+
+    if (stdout_forwarder == 0)
+	forward = false;
+
     MP_THREAD_GIL_EXIT();
+    p = buff;
     while (len--) {
         if (*str == '\n') {
+	    if (forward) {
+		if (p == e) {
+		    call_stdout_forwarder(buff, sizeof(buff));
+		    p = buff;
+		}
+		*p++ = '\r';
+	    }
             mp_hal_stdout_tx_char('\r');
         }
+	if (forward) {
+	    if (p == e) {
+		call_stdout_forwarder(buff, sizeof(buff));
+		p = buff;
+	    }
+	    *p++ = *str;
+	}
         mp_hal_stdout_tx_char(*str++);
     }
+    if (forward)
+	call_stdout_forwarder(buff, p - buff);
     MP_THREAD_GIL_ENTER();
 }
 
+void mp_hal_stdout_tx_str(const char *str) {
+    mp_hal_stdout_tx_str_x(str, true);
+}
+
+void mp_hal_stdout_tx_strn(const char *str, uint32_t len) {
+    mp_hal_stdout_tx_strn_x(str, len, true);
+}
+
+void mp_hal_stdout_tx_strn_cooked(const char *str, uint32_t len) {
+    mp_hal_stdout_tx_strn_cooked_x(str, len, true);
+}
+
 uint32_t mp_hal_ticks_ms(void) {
     struct timeval tv;
     gettimeofday(&tv, NULL);
diff --git a/ports/esp32/mphalport_add.h b/ports/esp32/mphalport_add.h
new file mode 100644
index 00000000..ff4f561f
--- /dev/null
+++ b/ports/esp32/mphalport_add.h
@@ -0,0 +1,43 @@
+/*
+ * This file is part of the MicroPython project, http://micropython.org/
+ *
+ * Development of the code in this file was sponsored by Microbric Pty Ltd
+ *
+ * The MIT License (MIT)
+ *
+ * Copyright (c) 2014 Damien P. George
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#ifndef INCLUDED_MPHALPORT_ADD_H
+#define INCLUDED_MPHALPORT_ADD_H
+
+#include "py/obj.h"
+
+void mp_hal_stdin_rx_insert(const char *data, mp_uint_t size);
+void mp_hal_set_stdout_forwarder(void (*forwarder)(const char *, uint32_t));
+void mp_hal_stdout_tx_str_x(const char *str, bool foward);
+void mp_hal_stdout_tx_strn_x(const char *str, uint32_t len, bool forward);
+void mp_hal_stdout_tx_strn_cooked_x(const char *str, uint32_t len, bool forward);
+
+bool mp_airterm_register(int socket);
+void mp_airterm_unregister(void);
+
+#endif // INCLUDED_MPHALPORT_H
