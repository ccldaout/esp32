diff --git a/ports/esp32/Makefile b/ports/esp32/Makefile
index d2d6192b..cd88a822 100644
--- a/ports/esp32/Makefile
+++ b/ports/esp32/Makefile
@@ -14,8 +14,8 @@ FROZEN_MPY_DIR = modules
 # include py core make definitions
 include $(TOP)/py/py.mk
 
-PORT ?= /dev/ttyUSB0
-BAUD ?= 460800
+PORT ?= /dev/ttyS2
+BAUD ?= 115200
 FLASH_MODE ?= dio
 FLASH_FREQ ?= 40m
 FLASH_SIZE ?= 4MB
@@ -132,6 +132,7 @@ SRC_C = \
 	uart.c \
 	gccollect.c \
 	mphalport.c \
+	vterm.c \
 	fatfs_port.c \
 	help.c \
 	modutime.c \
diff --git a/ports/esp32/main.c b/ports/esp32/main.c
index eebf183c..8893202b 100644
--- a/ports/esp32/main.c
+++ b/ports/esp32/main.c
@@ -48,6 +48,7 @@
 #include "uart.h"
 #include "modmachine.h"
 #include "mpthreadport.h"
+#include "vterm.h"
 
 // MicroPython runs as a task under FreeRTOS
 #define MP_TASK_PRIORITY        (ESP_TASK_PRIO_MIN + 1)
@@ -63,6 +64,7 @@ void mp_task(void *pvParameter) {
     mp_thread_init(&mp_task_stack[0], MP_TASK_STACK_LEN);
     #endif
     uart_init();
+    mp_vterm_init();
 
     // Allocate the uPy heap using malloc and get the largest available region
     size_t mp_task_heap_size = heap_caps_get_largest_free_block(MALLOC_CAP_8BIT);
diff --git a/ports/esp32/modsocket.c b/ports/esp32/modsocket.c
index 31d15396..45490b29 100644
--- a/ports/esp32/modsocket.c
+++ b/ports/esp32/modsocket.c
@@ -54,6 +54,8 @@
 #include "lwip/igmp.h"
 #include "esp_log.h"
 
+#include "vterm.h"
+
 #define SOCKET_POLL_US (100000)
 
 typedef struct _socket_obj_t {
@@ -222,6 +224,16 @@ STATIC mp_obj_t socket_setsockopt(size_t n_args, const mp_obj_t *args) {
             break;
         }
 
+        // level: IPPROTO_TCP
+        case TCP_NODELAY: {
+            int val = mp_obj_get_int(args[3]);
+            int ret = lwip_setsockopt_r(self->fd, IPPROTO_TCP, opt, &val, sizeof(int));
+            if (ret != 0) {
+                exception_from_errno(errno);
+            }
+            break;
+        }
+
         // level: IPPROTO_IP
         case IP_ADD_MEMBERSHIP: {
             mp_buffer_info_t bufinfo;
@@ -567,6 +579,19 @@ STATIC mp_obj_t esp_socket_initialize() {
 }
 STATIC MP_DEFINE_CONST_FUN_OBJ_0(esp_socket_initialize_obj, esp_socket_initialize);
 
+STATIC mp_obj_t socket_airterm(mp_obj_t arg) {
+    bool ret = true;
+    if (arg == mp_const_none) {
+	mp_vterm_unregister();
+    } else {
+	socket_obj_t *sock = MP_OBJ_TO_PTR(arg);
+	ret = mp_vterm_register_airterm(sock->fd);
+	sock->fd = -1;
+    }
+    return ret ? mp_const_true : mp_const_false;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(socket_airterm_obj, socket_airterm);
+
 STATIC const mp_map_elem_t mp_module_socket_globals_table[] = {
     { MP_OBJ_NEW_QSTR(MP_QSTR___name__), MP_OBJ_NEW_QSTR(MP_QSTR_usocket) },
     { MP_OBJ_NEW_QSTR(MP_QSTR___init__), (mp_obj_t)&esp_socket_initialize_obj },
@@ -584,6 +609,8 @@ STATIC const mp_map_elem_t mp_module_socket_globals_table[] = {
     { MP_OBJ_NEW_QSTR(MP_QSTR_SOL_SOCKET), MP_OBJ_NEW_SMALL_INT(SOL_SOCKET) },
     { MP_OBJ_NEW_QSTR(MP_QSTR_SO_REUSEADDR), MP_OBJ_NEW_SMALL_INT(SO_REUSEADDR) },
     { MP_OBJ_NEW_QSTR(MP_QSTR_IP_ADD_MEMBERSHIP), MP_OBJ_NEW_SMALL_INT(IP_ADD_MEMBERSHIP) },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_TCP_NODELAY), MP_OBJ_NEW_SMALL_INT(TCP_NODELAY) },
+    { MP_ROM_QSTR(MP_QSTR_airterm), (mp_obj_t)&socket_airterm_obj },
 };
 
 STATIC MP_DEFINE_CONST_DICT(mp_module_socket_globals, mp_module_socket_globals_table);
diff --git a/ports/esp32/modules/webrepl.py b/ports/esp32/modules/webrepl.py
new file mode 100644
index 00000000..ee11312b
--- /dev/null
+++ b/ports/esp32/modules/webrepl.py
@@ -0,0 +1,97 @@
+# This module should be imported from REPL, not run from command line.
+import sys
+import socket
+import uos
+import network
+import websocket
+import websocket_helper
+import _webrepl
+import machine
+
+listen_s = None
+client_s = None
+timer = None
+
+def setup_conn(port, accept_handler):
+    global listen_s
+    listen_s = socket.socket()
+    listen_s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
+
+    ai = socket.getaddrinfo("0.0.0.0", port)
+    addr = ai[0][4]
+
+    listen_s.bind(addr)
+    listen_s.listen(1)
+    if accept_handler:
+        listen_s.setblocking(False)
+        def manage(*args):
+            global client_s
+            try:
+                if client_s and client_s.fileno() == -1:
+                    client_s = None
+                    uos.dupterm(None)
+            except:
+                pass
+            try:
+                accept_conn(listen_s)
+            except:
+                pass
+        global timer
+        timer = machine.Timer(0)
+        timer.init(period=2000, mode=1, callback=manage)
+    for i in (network.AP_IF, network.STA_IF):
+        iface = network.WLAN(i)
+        if iface.active():
+            print("WebREPL daemon started on ws://%s:%d" % (iface.ifconfig()[0], port))
+    return listen_s
+
+
+def accept_conn(listen_sock):
+    global client_s
+    cl, remote_addr = listen_sock.accept()
+    prev = uos.dupterm(None)
+    uos.dupterm(prev)
+    if prev:
+        print("\nConcurrent WebREPL connection from", remote_addr, "rejected")
+        cl.close()
+        return
+    print("\nWebREPL connection from:", remote_addr)
+    client_s = cl
+    websocket_helper.server_handshake(cl)
+    ws = websocket.websocket(cl, True)
+    ws = _webrepl._webrepl(ws)
+    cl.setblocking(False)
+    uos.dupterm(ws)
+
+
+def stop():
+    global listen_s, client_s
+    uos.dupterm(None)
+    if client_s:
+        client_s.close()
+    if listen_s:
+        listen_s.close()
+    if timer:
+        timer.deinit()
+
+
+def start(port=8266, password=None):
+    stop()
+    if password is None:
+        try:
+            import webrepl_cfg
+            _webrepl.password(webrepl_cfg.PASS)
+            setup_conn(port, accept_conn)
+            print("Started webrepl in normal mode")
+        except:
+            print("WebREPL is not configured, run 'import webrepl_setup'")
+    else:
+        _webrepl.password(password)
+        setup_conn(port, accept_conn)
+        print("Started webrepl in manual override mode")
+
+
+def start_foreground(port=8266):
+    stop()
+    s = setup_conn(port, None)
+    accept_conn(s)
diff --git a/ports/esp32/modules/webrepl_setup.py b/ports/esp32/modules/webrepl_setup.py
new file mode 120000
index 00000000..999888bf
--- /dev/null
+++ b/ports/esp32/modules/webrepl_setup.py
@@ -0,0 +1 @@
+../../esp8266/modules/webrepl_setup.py
\ No newline at end of file
diff --git a/ports/esp32/modules/websocket_helper.py b/ports/esp32/modules/websocket_helper.py
new file mode 120000
index 00000000..4bcf3bcb
--- /dev/null
+++ b/ports/esp32/modules/websocket_helper.py
@@ -0,0 +1 @@
+../../esp8266/modules/websocket_helper.py
\ No newline at end of file
diff --git a/ports/esp32/moduos.c b/ports/esp32/moduos.c
index 9f0e291a..587e649e 100644
--- a/ports/esp32/moduos.c
+++ b/ports/esp32/moduos.c
@@ -36,10 +36,13 @@
 #include "py/objstr.h"
 #include "py/runtime.h"
 #include "py/mperrno.h"
+#include "py/stream.h"
 #include "extmod/vfs.h"
 #include "extmod/vfs_fat.h"
 #include "genhdr/mpversion.h"
 
+#include "vterm.h"
+
 extern const mp_obj_type_t mp_fat_vfs_type;
 
 STATIC const qstr os_uname_info_fields[] = {
@@ -84,23 +87,38 @@ STATIC mp_obj_t os_urandom(mp_obj_t num) {
 }
 STATIC MP_DEFINE_CONST_FUN_OBJ_1(os_urandom_obj, os_urandom);
 
-#if MICROPY_PY_OS_DUPTERM
-STATIC mp_obj_t os_dupterm_notify(mp_obj_t obj_in) {
-    (void)obj_in;
-    mp_hal_signal_dupterm_input();
-    return mp_const_none;
+STATIC mp_obj_t os_dupterm(size_t n_args, const mp_obj_t *args) {
+    STATIC mp_obj_t prev_stream;
+    mp_obj_t ret_stream = prev_stream;
+    if (args[0] == mp_const_none) {
+	prev_stream = mp_const_none;
+    } else if (args[0] == prev_stream) {
+	;
+    } else {
+	if (mp_get_stream_raise(args[0], MP_STREAM_OP_READ|MP_STREAM_OP_WRITE) != 0) {
+	    bool ret = false;
+	    prev_stream = args[0];
+	    mp_vterm_unregister();
+	    if (n_args == 3) {
+		mp_int_t thread_stack_size = mp_obj_get_int(args[2]);
+		if (thread_stack_size >= 0)
+		    ret = mp_vterm_register_dupterm(prev_stream, thread_stack_size);
+	    } else
+		ret = mp_vterm_register_dupterm_nonblocking(prev_stream);
+	    if (!ret) {
+		mp_raise_OSError(MP_EINVAL);
+	    }
+	}
+    }
+    return ret_stream;
 }
-STATIC MP_DEFINE_CONST_FUN_OBJ_1(os_dupterm_notify_obj, os_dupterm_notify);
-#endif
+STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(os_dupterm_obj, 1, 3, os_dupterm);
 
 STATIC const mp_rom_map_elem_t os_module_globals_table[] = {
     { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_uos) },
     { MP_ROM_QSTR(MP_QSTR_uname), MP_ROM_PTR(&os_uname_obj) },
     { MP_ROM_QSTR(MP_QSTR_urandom), MP_ROM_PTR(&os_urandom_obj) },
-    #if MICROPY_PY_OS_DUPTERM
-    { MP_ROM_QSTR(MP_QSTR_dupterm), MP_ROM_PTR(&mp_uos_dupterm_obj) },
-    { MP_ROM_QSTR(MP_QSTR_dupterm_notify), MP_ROM_PTR(&os_dupterm_notify_obj) },
-    #endif
+    { MP_ROM_QSTR(MP_QSTR_dupterm), MP_ROM_PTR(&os_dupterm_obj) },
     #if MICROPY_VFS
     { MP_ROM_QSTR(MP_QSTR_ilistdir), MP_ROM_PTR(&mp_vfs_ilistdir_obj) },
     { MP_ROM_QSTR(MP_QSTR_listdir), MP_ROM_PTR(&mp_vfs_listdir_obj) },
diff --git a/ports/esp32/mpconfigport.h b/ports/esp32/mpconfigport.h
index 80594b11..5a889528 100644
--- a/ports/esp32/mpconfigport.h
+++ b/ports/esp32/mpconfigport.h
@@ -141,6 +141,7 @@
 #define MICROPY_SSL_MBEDTLS                 (1)
 #define MICROPY_PY_USSL_FINALISER           (1)
 #define MICROPY_PY_WEBSOCKET                (1)
+#define MICROPY_PY_WEBREPL		    (1)
 #define MICROPY_PY_FRAMEBUF                 (1)
 
 // fatfs configuration
diff --git a/ports/esp32/mphalport.c b/ports/esp32/mphalport.c
index e588fc65..89eb0f69 100644
--- a/ports/esp32/mphalport.c
+++ b/ports/esp32/mphalport.c
@@ -27,6 +27,7 @@
  */
 
 #include <stdio.h>
+#include <string.h>
 #include <sys/time.h>
 
 #include "freertos/FreeRTOS.h"
@@ -42,12 +43,38 @@
 STATIC uint8_t stdin_ringbuf_array[256];
 ringbuf_t stdin_ringbuf = {stdin_ringbuf_array, sizeof(stdin_ringbuf_array)};
 
+static int noop_stdin_rx_chr(void)
+{
+    return -1;
+}
+
+static void noop_stdout_tx_strn(const char *str, uint32_t len)
+{
+}
+
+static int (*dup_stdin_rx_chr)(void) = noop_stdin_rx_chr;
+static void (*dup_stdout_tx_strn)(const char *str, uint32_t len) = noop_stdout_tx_strn;
+
+void mp_hal_stdin_dup(int (*rx_chr)(void))
+{
+    dup_stdin_rx_chr = rx_chr ? rx_chr : noop_stdin_rx_chr;
+}
+
+void mp_hal_stdout_dup(void (*tx_strn)(const char *str, uint32_t len))
+{
+    dup_stdout_tx_strn = tx_strn ? tx_strn : noop_stdout_tx_strn;
+}
+
 int mp_hal_stdin_rx_chr(void) {
     for (;;) {
         int c = ringbuf_get(&stdin_ringbuf);
         if (c != -1) {
             return c;
         }
+	c = dup_stdin_rx_chr();
+        if (c != -1) {
+            return c;
+        }
         MICROPY_EVENT_POLL_HOOK
         vTaskDelay(1);
     }
@@ -55,11 +82,11 @@ int mp_hal_stdin_rx_chr(void) {
 
 void mp_hal_stdout_tx_char(char c) {
     uart_tx_one_char(c);
-    //mp_uos_dupterm_tx_strn(&c, 1);
 }
 
 void mp_hal_stdout_tx_str(const char *str) {
     MP_THREAD_GIL_EXIT();
+    dup_stdout_tx_strn(str, strlen(str));
     while (*str) {
         mp_hal_stdout_tx_char(*str++);
     }
@@ -68,6 +95,7 @@ void mp_hal_stdout_tx_str(const char *str) {
 
 void mp_hal_stdout_tx_strn(const char *str, uint32_t len) {
     MP_THREAD_GIL_EXIT();
+    dup_stdout_tx_strn(str, len);
     while (len--) {
         mp_hal_stdout_tx_char(*str++);
     }
@@ -75,13 +103,19 @@ void mp_hal_stdout_tx_strn(const char *str, uint32_t len) {
 }
 
 void mp_hal_stdout_tx_strn_cooked(const char *str, uint32_t len) {
+    const char *p = str;
+    const char cr = '\r';
     MP_THREAD_GIL_EXIT();
     while (len--) {
         if (*str == '\n') {
-            mp_hal_stdout_tx_char('\r');
+	    dup_stdout_tx_strn(p, str - p);
+	    dup_stdout_tx_strn(&cr, 1);
+	    p = str;
+            mp_hal_stdout_tx_char(cr);
         }
         mp_hal_stdout_tx_char(*str++);
     }
+    dup_stdout_tx_strn(p, str - p);
     MP_THREAD_GIL_ENTER();
 }
 
diff --git a/ports/esp32/mphalport.h b/ports/esp32/mphalport.h
index 3215bc06..0811f2af 100644
--- a/ports/esp32/mphalport.h
+++ b/ports/esp32/mphalport.h
@@ -34,6 +34,9 @@
 
 extern ringbuf_t stdin_ringbuf;
 
+void mp_hal_stdin_dup(int (*rx_chr)(void));
+void mp_hal_stdout_dup(void (*tx_strn)(const char *str, uint32_t len));
+
 uint32_t mp_hal_ticks_us(void);
 __attribute__((always_inline)) static inline uint32_t mp_hal_ticks_cpu(void) {
   uint32_t ccount;
diff --git a/ports/esp32/mpthreadport.c b/ports/esp32/mpthreadport.c
index 76d9431c..54b324ff 100644
--- a/ports/esp32/mpthreadport.c
+++ b/ports/esp32/mpthreadport.c
@@ -37,8 +37,8 @@
 
 #if MICROPY_PY_THREAD
 
-#define MP_THREAD_MIN_STACK_SIZE                        (4 * 1024)
-#define MP_THREAD_DEFAULT_STACK_SIZE                    (MP_THREAD_MIN_STACK_SIZE + 1024)
+#define MP_THREAD_MIN_STACK_SIZE                        (1 * 1024)
+#define MP_THREAD_DEFAULT_STACK_SIZE                    (5 * 1024)
 #define MP_THREAD_PRIORITY                              (ESP_TASK_PRIO_MIN + 1)
 
 // this structure forms a linked list, one node per active thread
diff --git a/ports/esp32/vterm.c b/ports/esp32/vterm.c
new file mode 100644
index 00000000..5a8400da
--- /dev/null
+++ b/ports/esp32/vterm.c
@@ -0,0 +1,412 @@
+/*
+ * This file is part of the MicroPython project, http://micropython.org/
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "freertos/FreeRTOS.h"
+#include "freertos/semphr.h"
+#include "freertos/ringbuf.h"
+#include "esp_timer.h"
+#include "mphalport.h"
+#include "lwip/sockets.h"
+#include "py/stream.h"
+#include "py/mpthread.h"
+
+#include "vterm.h"
+
+#define BUFSIZE_b 		128
+#define PUSH_WAIT_tick		( 1000 / portTICK_PERIOD_MS)
+#define UNREG_WAIT_tick		( 1000 / portTICK_PERIOD_MS)
+#define RINGBUF_WAIT_tick	(60000 / portTICK_PERIOD_MS)
+#define IO_INTERVAL_us		(20 * 1000)
+#define RINGBUF_SIZE_b		(16)
+
+typedef struct _vterm_ops_t {
+    bool nonblocking_read;
+    bool buffered_write;
+    int stacksize_b;		// blocking read thread
+    ssize_t (*read)(void *vctx, void *buf, size_t n, bool in_gil);
+    ssize_t (*write)(void *vctx, const void *buf, size_t n, bool in_gil);
+    void (*unregister)(void *vctx);
+} _vterm_ops_t;
+
+typedef struct _vterm_t {
+    void *vctx;
+    bool nonblocking_read;
+    bool buffered_write;
+    int stacksize_b;		// blocking read thread
+    ssize_t (*read)(void *vctx, void *buf, size_t n, bool in_gil);
+    ssize_t (*write)(void *vctx, const void *buf, size_t n, bool in_gil);
+    void (*unregister)(void *vctx);
+    esp_timer_handle_t timer;
+    SemaphoreHandle_t mutex;
+    RingbufHandle_t ringbuf;
+    char s_buff[BUFSIZE_b];
+    size_t s_size;
+} _vterm_t;
+
+
+//----------------------------------------------------------------------------
+//----------------------------------------------------------------------------
+
+STATIC ssize_t _vterm_read_noop(void *vctx, void *buf, size_t n, bool in_gil)
+{
+    return -1;
+}
+
+STATIC ssize_t _vterm_write_noop(void *vctx, const void *buf, size_t n, bool in_gil)
+{
+    return -1;
+}
+
+STATIC void _vterm_unregister_noop(void *vctx)
+{
+}
+
+STATIC _vterm_t vterm = {
+    .read = _vterm_read_noop,
+    .write = _vterm_write_noop,
+    .unregister = _vterm_unregister_noop,
+};
+
+STATIC void *_vterm_read_thread(void *__void)
+{
+    unsigned char buf[RINGBUF_SIZE_b];
+    for (;;) {
+	ssize_t n = vterm.read(vterm.vctx, buf, sizeof(buf), false);
+	if (n > 0) {
+	    if (xRingbufferSend(vterm.ringbuf, buf, n, RINGBUF_WAIT_tick) != pdTRUE) {
+		// drop input
+	    }
+	}
+	if (n == -1)
+	    return 0;
+    }
+}
+
+STATIC int mp_vterm_rx_by_thread(void)
+{
+    size_t n;
+    unsigned char *p = xRingbufferReceiveUpTo(vterm.ringbuf, &n, 0, 1);
+    if (p != 0) {
+	int c = *p;
+	vRingbufferReturnItem(vterm.ringbuf, p);
+	return c;
+    }
+    return -1;
+}
+
+STATIC int mp_vterm_rx_nonblocking(void)
+{
+    unsigned char buf[1];
+    ssize_t n = vterm.read(vterm.vctx, buf, sizeof(buf), true);
+    if (n > 0)
+	return buf[0];
+    if (n == -2)
+	return -1;
+    mp_vterm_unregister();
+    return -1;
+}
+
+STATIC void _vterm_writeall(const char *data, uint32_t size, bool in_gil)
+{
+    while (size > 0) {
+	int n = vterm.write(vterm.vctx, data, size, in_gil);
+	if (n < 0) {
+	    mp_vterm_unregister();
+	    return;
+	}
+	data += n;
+	size -= n;
+    }
+}
+
+STATIC void mp_vterm_wr_direct(const char *data, uint32_t size)
+{
+    return _vterm_writeall(data, size, false);
+}
+
+STATIC void mp_vterm_wx_buffer(const char *data, uint32_t size)
+{
+    if (xSemaphoreTake(vterm.mutex, PUSH_WAIT_tick) == pdFALSE) {
+	return;
+    }
+    if (vterm.s_size + size > BUFSIZE_b) {
+	_vterm_writeall(vterm.s_buff, vterm.s_size, false);
+	_vterm_writeall(data, size, false);
+	vterm.s_size = 0;
+    } else {
+	(void)memcpy(&vterm.s_buff[vterm.s_size], data, size);
+	vterm.s_size += size;
+    }
+    xSemaphoreGive(vterm.mutex);
+}
+
+STATIC void _vterm_flush(bool in_gil)
+{
+    if (xSemaphoreTake(vterm.mutex, 0) == pdTRUE) {
+	if (vterm.s_size != 0) {
+	    _vterm_writeall(vterm.s_buff, vterm.s_size, in_gil);
+	    vterm.s_size = 0;
+	}
+	xSemaphoreGive(vterm.mutex);
+    }
+}
+
+STATIC void mp_vterm_timered_flush(void *__arg)
+{
+    _vterm_flush(false);
+}
+
+STATIC bool mp_vterm_register(void *vctx, const _vterm_ops_t *ops)
+{
+    vterm.vctx = vctx;
+    vterm.nonblocking_read = ops->nonblocking_read;
+    vterm.buffered_write = ops->buffered_write;
+    vterm.write = ops->write;
+    vterm.read = ops->read;
+    vterm.unregister = ops->unregister;
+    vterm.s_size = 0;
+
+    if (vterm.mutex == 0) {
+	return false;
+    }
+
+    if (vterm.buffered_write) {
+	if (vterm.timer == 0) {
+	    return false;
+	}
+	if (esp_timer_start_periodic(vterm.timer, IO_INTERVAL_us) != ESP_OK) {
+	    esp_timer_delete(vterm.timer);
+	    vterm.timer = 0;
+	    return false;
+	}
+    }
+
+    if (vterm.buffered_write)
+	mp_hal_stdout_dup(mp_vterm_wx_buffer);
+    else
+	mp_hal_stdout_dup(mp_vterm_wr_direct);
+
+    if (vterm.nonblocking_read)
+	mp_hal_stdin_dup(mp_vterm_rx_nonblocking);
+    else {
+	size_t n;
+	void *p = xRingbufferReceive(vterm.ringbuf, &n, 0);
+	if (p != 0)
+	    vRingbufferReturnItem(vterm.ringbuf, p);
+	mp_hal_stdin_dup(mp_vterm_rx_by_thread);
+	size_t stksize = vterm.stacksize_b;
+	mp_thread_create(_vterm_read_thread, 0, &stksize);
+    }
+
+    return true;
+}
+
+void mp_vterm_unregister(void)
+{
+    if (vterm.buffered_write)
+	esp_timer_stop(vterm.timer);
+
+    bool do_unlock = true;
+    if (xSemaphoreTake(vterm.mutex, UNREG_WAIT_tick) == pdFALSE) {
+	do_unlock = false;
+    }
+
+    void (*unregister)(void *vctx) = vterm.unregister;
+    vterm.read = _vterm_read_noop;
+    vterm.write = _vterm_write_noop;
+    vterm.unregister = _vterm_unregister_noop;
+    mp_hal_stdin_dup(0);
+    mp_hal_stdout_dup(0);
+    unregister(vterm.vctx);
+    vterm.s_size = 0;
+
+    if (do_unlock)
+	xSemaphoreGive(vterm.mutex);
+}
+
+void mp_vterm_init(void)
+{
+    if (vterm.mutex == 0) {
+	vterm.mutex = xSemaphoreCreateMutex();
+	vterm.ringbuf = xRingbufferCreate(RINGBUF_SIZE_b, RINGBUF_TYPE_BYTEBUF);
+	esp_timer_create_args_t args = {
+	    .callback = mp_vterm_timered_flush,
+	    .arg = 0,
+	    .dispatch_method = ESP_TIMER_TASK,
+	    .name = "airterm",
+	};
+	esp_timer_create(&args, &vterm.timer);
+    }
+}
+
+//----------------------------------------------------------------------------
+//             airterm - LWIP socket level terminal duplication
+//----------------------------------------------------------------------------
+
+typedef struct _airterm_ctx_t {
+    int socket;
+} _airterm_ctx_t;
+
+static _airterm_ctx_t airterm_ctx;
+
+STATIC ssize_t airterm_read(void *__vctx, void *buf, size_t n, bool in_gil)
+{
+    _airterm_ctx_t *ctx = __vctx;
+    ssize_t z = lwip_recvfrom_r(ctx->socket, buf, n, MSG_DONTWAIT, 0, 0);
+    if (z == -1 && errno == EWOULDBLOCK)
+	z = -2;
+    return z;
+}
+
+STATIC ssize_t airterm_write(void *__vctx, const void *buf, size_t n, bool in_gil)
+{
+    _airterm_ctx_t *ctx = __vctx;
+    if (in_gil)
+	MP_THREAD_GIL_EXIT();
+    ssize_t z = lwip_send_r(ctx->socket, buf, n, 0);
+    if (in_gil)
+	MP_THREAD_GIL_ENTER();
+    return z;
+}
+
+STATIC void airterm_unregister(void *__vctx)
+{
+    _airterm_ctx_t *ctx = __vctx;
+    if (ctx->socket != -1) {
+	lwip_close_r(ctx->socket);
+    }
+    ctx->socket = -1;
+}
+
+bool mp_vterm_register_airterm(int socket)
+{
+    //int enable = 1;
+    //lwip_setsockopt(socket, IPPROTO_TCP, TCP_NODELAY, &enable, sizeof(enable));
+    airterm_ctx.socket = socket;
+
+    _vterm_ops_t ops = {
+	.nonblocking_read = true,
+	.buffered_write = true,
+	.read = airterm_read,
+	.write = airterm_write,
+	.unregister = airterm_unregister,
+    };
+
+    return mp_vterm_register(&airterm_ctx, &ops);
+}
+
+//----------------------------------------------------------------------------
+//              dupterm - altenative os.dupterm implementation
+//----------------------------------------------------------------------------
+
+typedef struct _dupterm_ctx_t {
+    mp_obj_t stream;
+} _dupterm_ctx_t;
+
+static _dupterm_ctx_t dupterm_ctx;
+
+STATIC ssize_t dupterm_read_nonblocking(void *__vctx, void *buf, size_t n, bool in_gil)
+{
+    _dupterm_ctx_t *ctx = __vctx;
+    int flag = MP_STREAM_RW_READ|MP_STREAM_RW_ONCE;
+    int errcode, z;
+    if (!in_gil)
+	MP_THREAD_GIL_ENTER();
+    z = mp_stream_rw(ctx->stream, buf, 1, &errcode, flag);
+    if (!in_gil)
+	MP_THREAD_GIL_EXIT();
+    if (errcode == 0)
+	return z;
+    if (errcode == MP_EWOULDBLOCK)
+	return -2;
+    return -1;
+}
+
+STATIC ssize_t dupterm_read(void *__vctx, void *buf, size_t n, bool in_gil)
+{
+    _dupterm_ctx_t *ctx = __vctx;
+    int flag = MP_STREAM_RW_READ|MP_STREAM_RW_ONCE;
+    int errcode, z;
+    if (!in_gil)
+	MP_THREAD_GIL_ENTER();
+    do {
+	z = mp_stream_rw(ctx->stream, buf, 1, &errcode, flag);
+    } while (errcode == MP_EWOULDBLOCK);
+    if (!in_gil)
+	MP_THREAD_GIL_EXIT();
+    if (errcode == 0)
+	return z;
+    return -1;
+}
+
+STATIC ssize_t dupterm_write(void *__vctx, const void *buf, size_t n, bool in_gil)
+{
+    _dupterm_ctx_t *ctx = __vctx;
+    int errcode;
+    size_t z;
+    if (!in_gil)
+	MP_THREAD_GIL_ENTER();
+    z = mp_stream_rw(ctx->stream, (void *)buf, n, &errcode, MP_STREAM_RW_WRITE);
+    if (!in_gil)
+	MP_THREAD_GIL_EXIT();
+    if (errcode == 0)
+	return z;
+    return -1;
+}
+
+STATIC void dupterm_unregister(void *__vctx)
+{
+    _dupterm_ctx_t *ctx = __vctx;
+    (void)mp_stream_close(ctx->stream);
+    ctx->stream = 0;
+}
+
+bool mp_vterm_register_dupterm_nonblocking(mp_obj_t stream)
+{
+    _vterm_ops_t ops = {
+	.nonblocking_read = true,
+	.buffered_write = true,
+	.read = dupterm_read_nonblocking,
+	.write = dupterm_write,
+	.unregister = dupterm_unregister,
+    };
+    dupterm_ctx.stream = stream;
+    return mp_vterm_register(&dupterm_ctx, &ops);
+}
+
+bool mp_vterm_register_dupterm(mp_obj_t stream, int stacksize_b)
+{
+    _vterm_ops_t ops = {
+	.nonblocking_read = false,
+	.buffered_write = true,
+	.stacksize_b = stacksize_b,
+	.read = dupterm_read,
+	.write = dupterm_write,
+	.unregister = dupterm_unregister,
+    };
+    dupterm_ctx.stream = stream;
+    return mp_vterm_register(&dupterm_ctx, &ops);
+}
diff --git a/ports/esp32/vterm.h b/ports/esp32/vterm.h
new file mode 100644
index 00000000..010ee9e8
--- /dev/null
+++ b/ports/esp32/vterm.h
@@ -0,0 +1,38 @@
+/*
+ * This file is part of the MicroPython project, http://micropython.org/
+ *
+ * Development of the code in this file was sponsored by Microbric Pty Ltd
+ *
+ * The MIT License (MIT)
+ *
+ * Copyright (c) 2014 Damien P. George
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#ifndef INCLUDED_VTERM_H
+#define INCLUDED_VTERM_H
+
+void mp_vterm_init(void);
+bool mp_vterm_register_airterm(int socket);
+bool mp_vterm_register_dupterm_nonblocking(mp_obj_t stream);
+bool mp_vterm_register_dupterm(mp_obj_t stream, int stacksize_b);
+void mp_vterm_unregister(void);
+
+#endif // INCLUDED_VTERM_H
