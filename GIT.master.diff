diff --git a/extmod/modgenstream.c b/extmod/modgenstream.c
new file mode 100644
index 00000000..f1e28a7f
--- /dev/null
+++ b/extmod/modgenstream.c
@@ -0,0 +1,109 @@
+/*
+ * This file is part of the MicroPython project, http://micropython.org/
+ *
+ * The MIT License (MIT)
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+
+#include "py/objstr.h"
+#include "py/runtime.h"
+#include "py/stream.h"
+#include "extmod/modgenstream.h"
+
+#if MICROPY_PY_GENSTREAM
+
+typedef struct _mp_obj_genstream_t {
+    mp_obj_base_t base;
+} mp_obj_genstream_t;
+
+STATIC mp_obj_t genstream_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {
+    //mp_arg_check_num(n_args, n_kw, 0, 0, false);
+    mp_obj_genstream_t *o = m_new_obj(mp_obj_genstream_t);
+    o->base.type = type;
+    return  MP_OBJ_FROM_PTR(o);
+}
+
+STATIC mp_uint_t genstream_read(mp_obj_t self_in, void *buf, mp_uint_t size, int *errcode) {
+    mp_obj_genstream_t *self =  MP_OBJ_TO_PTR(self_in);
+    mp_obj_t meth[3];
+    mp_load_method(self, MP_QSTR_read, meth);
+    meth[2] = mp_obj_new_int(size);
+
+    mp_obj_t ret;
+    nlr_buf_t nlr;
+    if (nlr_push(&nlr) == 0) {
+	ret = mp_call_method_n_kw(1, 0, meth);
+	nlr_pop();
+    } else {
+	*errcode = MP_EIO;
+	return MP_STREAM_ERROR;
+    }
+    const char *data = mp_obj_str_get_data(ret, &size);
+    (void)memcpy(buf, data, size);
+    return size;
+}
+
+STATIC mp_uint_t genstream_write(mp_obj_t self_in, const void *buf, mp_uint_t size, int *errcode) {
+    mp_obj_genstream_t *self =  MP_OBJ_TO_PTR(self_in);
+    mp_obj_t meth[3];
+    mp_load_method(self, MP_QSTR_write, meth);
+    meth[2] = mp_obj_new_str_of_type(&mp_type_bytes, buf, size);
+
+    mp_obj_t ret;
+    nlr_buf_t nlr;
+    if (nlr_push(&nlr) == 0) {
+	ret = mp_call_method_n_kw(1, 0, meth);
+	nlr_pop();
+    } else {
+	*errcode = MP_EIO;
+	return MP_STREAM_ERROR;
+    }
+    return mp_obj_get_int(ret);
+}
+
+STATIC const mp_stream_p_t genstream_stream_p = {
+    .read = genstream_read,
+    .write = genstream_write,
+};
+
+STATIC const mp_obj_type_t genstream_type = {
+    { &mp_type_type },
+    .name = MP_QSTR_genstream,
+    .make_new = genstream_make_new,
+    .protocol = &genstream_stream_p,
+};
+
+STATIC const mp_rom_map_elem_t genstream_module_globals_table[] = {
+    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_genstream) },
+    { MP_ROM_QSTR(MP_QSTR_genstream), MP_ROM_PTR(&genstream_type) },
+};
+
+STATIC MP_DEFINE_CONST_DICT(genstream_module_globals, genstream_module_globals_table);
+
+const mp_obj_module_t mp_module_genstream = {
+    .base = { &mp_type_module },
+    .globals = (mp_obj_dict_t*)&genstream_module_globals,
+};
+
+#endif // MICROPY_PY_GENSTREAM
diff --git a/extmod/modgenstream.h b/extmod/modgenstream.h
new file mode 100644
index 00000000..983911af
--- /dev/null
+++ b/extmod/modgenstream.h
@@ -0,0 +1,4 @@
+#ifndef MICROPY_INCLUDED_EXTMOD_MODGENSTREAM_H
+#define MICROPY_INCLUDED_EXTMOD_MODGENSTREAM_H
+
+#endif // MICROPY_INCLUDED_EXTMOD_MODGENSTREAM_H
diff --git a/extmod/vfs.c b/extmod/vfs.c
index 0585de1c..af31e628 100644
--- a/extmod/vfs.c
+++ b/extmod/vfs.c
@@ -131,7 +131,18 @@ mp_import_stat_t mp_vfs_import_stat(const char *path) {
     }
     #endif
     // TODO delegate to vfs.stat() method
-    return MP_IMPORT_STAT_NO_EXIST;
+
+    // $$$$
+    mp_obj_t path_out2 = mp_obj_new_str_copy(&mp_type_str, (const byte *)path_out, strlen(path_out));
+    mp_obj_t stat = mp_vfs_proxy_call(vfs, MP_QSTR_stat, 1, &path_out2);
+    mp_obj_tuple_t *t = MP_OBJ_TO_PTR(stat);
+    int mode = mp_obj_get_int(t->items[0]);
+    if ((mode & MP_S_IFDIR) != 0)
+	return MP_IMPORT_STAT_DIR;
+    else if ((mode & MP_S_IFREG) != 0)
+	return MP_IMPORT_STAT_FILE;
+    else
+	return MP_IMPORT_STAT_NO_EXIST;
 }
 
 mp_obj_t mp_vfs_mount(size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {
diff --git a/ports/esp32/Makefile b/ports/esp32/Makefile
index d2d6192b..15464553 100644
--- a/ports/esp32/Makefile
+++ b/ports/esp32/Makefile
@@ -14,8 +14,8 @@ FROZEN_MPY_DIR = modules
 # include py core make definitions
 include $(TOP)/py/py.mk
 
-PORT ?= /dev/ttyUSB0
-BAUD ?= 460800
+PORT ?= /dev/ttyS2
+BAUD ?= 115200
 FLASH_MODE ?= dio
 FLASH_FREQ ?= 40m
 FLASH_SIZE ?= 4MB
@@ -132,6 +132,7 @@ SRC_C = \
 	uart.c \
 	gccollect.c \
 	mphalport.c \
+	vterm.c \
 	fatfs_port.c \
 	help.c \
 	modutime.c \
@@ -150,6 +151,7 @@ SRC_C = \
 	modesp.c \
 	modesp32.c \
 	moduhashlib.c \
+	modmpoll.c \
 	espneopixel.c \
 	machine_hw_spi.c \
 	machine_wdt.c \
diff --git a/ports/esp32/machine_uart.c b/ports/esp32/machine_uart.c
index 26cbc88f..41971a79 100644
--- a/ports/esp32/machine_uart.c
+++ b/ports/esp32/machine_uart.c
@@ -242,7 +242,8 @@ STATIC mp_obj_t machine_uart_make_new(const mp_obj_type_t *type, size_t n_args,
     uart_param_config(self->uart_num, &uartcfg);
 
     // RX and TX buffers are currently hardcoded at 256 bytes each (IDF minimum).
-    uart_driver_install(uart_num, 256, 256, 10, &UART_QUEUE[self->uart_num], 0);
+    //uart_driver_install(uart_num, 256, 256, 10, &UART_QUEUE[self->uart_num], 0);
+    uart_driver_install(uart_num, 256, 256, 0, NULL, 0);
 
     mp_map_t kw_args;
     mp_map_init_fixed_table(&kw_args, n_kw, args + n_args);
diff --git a/ports/esp32/main.c b/ports/esp32/main.c
index eebf183c..8893202b 100644
--- a/ports/esp32/main.c
+++ b/ports/esp32/main.c
@@ -48,6 +48,7 @@
 #include "uart.h"
 #include "modmachine.h"
 #include "mpthreadport.h"
+#include "vterm.h"
 
 // MicroPython runs as a task under FreeRTOS
 #define MP_TASK_PRIORITY        (ESP_TASK_PRIO_MIN + 1)
@@ -63,6 +64,7 @@ void mp_task(void *pvParameter) {
     mp_thread_init(&mp_task_stack[0], MP_TASK_STACK_LEN);
     #endif
     uart_init();
+    mp_vterm_init();
 
     // Allocate the uPy heap using malloc and get the largest available region
     size_t mp_task_heap_size = heap_caps_get_largest_free_block(MALLOC_CAP_8BIT);
diff --git a/ports/esp32/modmpoll.c b/ports/esp32/modmpoll.c
new file mode 100644
index 00000000..beee296b
--- /dev/null
+++ b/ports/esp32/modmpoll.c
@@ -0,0 +1,343 @@
+/*
+ * This file is part of the MicroPython project, http://micropython.org/
+ *
+ * The MIT License (MIT)
+ *
+ * Copyright (c) 2014 Damien P. George
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#include "py/mpconfig.h"
+#if MICROPY_PY_MPOLL
+
+#include <stdio.h>
+#include <string.h>
+
+#include "py/runtime.h"
+#include "py/obj.h"
+#include "py/objlist.h"
+#include "py/stream.h"
+#include "py/mperrno.h"
+#include "py/mphal.h"
+
+#include "lwip/sockets.h"
+
+#include "modsocket.h"
+
+// Flags for poll()
+#define FLAG_ONESHOT (1)
+
+/// \class Poll - poll class
+
+//LWIP_SOCKET_OFFSET
+//CONFIG_LWIP_MAX_SOCKETS
+
+typedef struct _mp_obj_mpoll_t {
+    mp_obj_base_t base;
+    fd_set rset;
+    fd_set wset;
+    fd_set rset_result;
+    fd_set wset_result;
+    socket_obj_t *socks[CONFIG_LWIP_MAX_SOCKETS];
+    int maxfd;
+    //short iter_cnt;
+    short iter_idx;
+    int flags;
+    // callee-owned tuple
+    mp_obj_t ret_tuple;
+} mp_obj_mpoll_t;
+
+/// \method register(obj[, eventmask])
+STATIC mp_obj_t poll_register(uint n_args, const mp_obj_t *args) {
+    mp_obj_mpoll_t *self = args[0];
+    mp_uint_t flags;
+    if (n_args == 3) {
+        flags = mp_obj_get_int(args[2]);
+    } else {
+        flags = MP_STREAM_POLL_RD | MP_STREAM_POLL_WR;
+    }
+    socket_obj_t *socket = MP_OBJ_TO_PTR(args[1]);	// [TODO] CHECK TYPE
+    if ((flags & MP_STREAM_POLL_RD) != 0)
+	FD_SET(socket->fd, &self->rset);
+    if ((flags & MP_STREAM_POLL_WR) != 0)
+	FD_SET(socket->fd, &self->wset);
+    self->socks[socket->fd - LWIP_SOCKET_OFFSET] = socket;
+    if (socket->fd > self->maxfd)
+	self->maxfd = socket->fd;
+    return mp_const_none;
+}
+MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mpoll_register_obj, 2, 3, poll_register);
+
+/// \method unregister(obj)
+STATIC mp_obj_t poll_unregister(mp_obj_t self_in, mp_obj_t obj_in) {
+    mp_obj_mpoll_t *self = self_in;
+    socket_obj_t *socket = MP_OBJ_TO_PTR(obj_in);	// [TODO] CHECK TYPE
+    if (self->socks[socket->fd - LWIP_SOCKET_OFFSET] == NULL)
+	return mp_const_none;				// [TODO] raise KeyError
+    FD_CLR(socket->fd, &self->rset);
+    FD_CLR(socket->fd, &self->wset);
+    self->socks[socket->fd - LWIP_SOCKET_OFFSET] = NULL;
+    if (socket->fd == self->maxfd) {
+	int i;
+	for (i = self->maxfd - 1; i >= LWIP_SOCKET_OFFSET; i--) {
+	    if (self->socks[i - LWIP_SOCKET_OFFSET] != NULL)
+		break;
+	}
+	self->maxfd = i;
+    }
+    return mp_const_none;
+}
+MP_DEFINE_CONST_FUN_OBJ_2(mpoll_unregister_obj, poll_unregister);
+
+/// \method modify(obj, eventmask)
+STATIC mp_obj_t poll_modify(mp_obj_t self_in, mp_obj_t obj_in, mp_obj_t eventmask_in) {
+    mp_obj_mpoll_t *self = self_in;
+    socket_obj_t *socket = MP_OBJ_TO_PTR(obj_in);	// [TODO] CHECK TYPE
+    mp_uint_t flags = mp_obj_get_int(eventmask_in);
+    if (self->socks[socket->fd - LWIP_SOCKET_OFFSET] != NULL) {
+	FD_CLR(socket->fd, &self->rset);
+	FD_CLR(socket->fd, &self->wset);
+	if ((flags & MP_STREAM_POLL_RD) != 0)
+	    FD_SET(socket->fd, &self->rset);
+	if ((flags & MP_STREAM_POLL_WR) != 0)
+	    FD_SET(socket->fd, &self->wset);
+    } else
+	;						// [TODO] rais KeyError
+    return mp_const_none;
+}
+MP_DEFINE_CONST_FUN_OBJ_3(mpoll_modify_obj, poll_modify);
+
+STATIC void remove_invalids(mp_obj_mpoll_t *self)
+{
+    fd_set testset;
+    struct timeval testtmo = {.tv_sec=0, .tv_usec=0};
+    FD_ZERO(&testset);
+    for (int i = 0; i < CONFIG_LWIP_MAX_SOCKETS; i++) {
+	if (self->socks[i] == NULL)
+	    continue;
+	int fd = i + LWIP_SOCKET_OFFSET;
+	FD_SET(fd, &testset);
+	if (lwip_select(fd+1, &testset, NULL, NULL, &testtmo) == -1) {
+	    FD_CLR(fd, &self->rset);
+	    FD_CLR(fd, &self->wset);
+	    self->socks[i] = NULL;
+	}
+    }
+}
+
+STATIC int get_delay_ms(const struct timeval *target, int delay_ms)
+{
+    struct timeval now, trg = *target;
+    (void)gettimeofday(&now, NULL);
+    
+    trg.tv_sec -= now.tv_sec;
+    if (trg.tv_usec < now.tv_usec) {
+	trg.tv_sec--;
+	trg.tv_usec += 1000000;
+    }
+    trg.tv_usec -= now.tv_usec;
+    int diff_ms = now.tv_sec*1000 + now.tv_usec/1000;
+    if (diff_ms < 0)
+	return 0;
+    return (diff_ms > delay_ms) ? delay_ms : diff_ms;
+}
+
+STATIC mp_uint_t poll_poll_internal(uint n_args, const mp_obj_t *args) {
+    mp_obj_mpoll_t *self = args[0];
+    struct timeval timeout;
+    struct timeval target_time;
+    bool in_main = mp_thread_is_main();
+    const int interval_ms = 20;
+
+    // work out timeout (its given already in ms)
+    mp_uint_t timeout_ms = -1;
+    self->flags = 0;
+    if (n_args >= 2) {
+        if (args[1] != mp_const_none)
+	    timeout_ms = mp_obj_get_int(args[1]);
+        if (n_args >= 3)
+            self->flags = mp_obj_get_int(args[2]);
+    }
+
+    if (timeout_ms > 0) {
+	(void)gettimeofday(&target_time, NULL);
+	target_time.tv_sec += (timeout_ms / 1000);
+	target_time.tv_usec += (timeout_ms % 1000) * 1000;
+	if (target_time.tv_usec >= 1000000) {
+	    target_time.tv_usec -= 1000000;
+	    target_time.tv_sec += 1;
+	}
+    }
+
+    for (;;) {
+	int nready;
+	int delay_ms = timeout_ms == 0 ? 0 : get_delay_ms(&target_time, interval_ms);
+	if (self->maxfd == LWIP_SOCKET_OFFSET - 1) {
+	    vTaskDelay(delay_ms / portTICK_PERIOD_MS);
+	    nready = 0;
+	} else {
+	    timeout.tv_sec = 0;
+	    timeout.tv_usec = delay_ms * 1000;
+	    self->rset_result = self->rset;
+	    self->wset_result = self->wset;
+	    nready = lwip_select(self->maxfd+1, &self->rset_result, &self->wset_result, NULL, &timeout);
+	}
+	if (nready > 0)
+	    return nready;
+	if (nready == 0) {
+	    if (delay_ms < interval_ms)
+		return 0;
+	} else
+	    remove_invalids(self);
+	if (in_main) {
+	    MP_THREAD_GIL_ENTER();
+	    mp_handle_pending();
+	    MP_THREAD_GIL_EXIT();
+	}
+    }
+}
+
+STATIC mp_obj_t poll_poll(uint n_args, const mp_obj_t *args) {
+    mp_obj_mpoll_t *self = args[0];
+    MP_THREAD_GIL_EXIT();
+    mp_uint_t n_ready = poll_poll_internal(n_args, args);
+    MP_THREAD_GIL_ENTER();
+
+    // one or more objects are ready, or we had a timeout
+    mp_obj_list_t *ret_list = mp_obj_new_list(n_ready, NULL);
+    n_ready = 0;
+    for (int i = 0; i < CONFIG_LWIP_MAX_SOCKETS; i++) {
+	if (self->socks[i] == NULL)
+	    continue;
+	int fd = i + LWIP_SOCKET_OFFSET;
+	int flags = 0;
+	if (FD_ISSET(fd, &self->rset_result))
+	    flags |= MP_STREAM_POLL_RD;
+	if (FD_ISSET(fd, &self->wset_result))
+	    flags |= MP_STREAM_POLL_WR;
+	if (flags == 0)
+	    continue;
+	mp_obj_t tuple[2] = {MP_OBJ_FROM_PTR(self->socks[i]), MP_OBJ_NEW_SMALL_INT(flags)};
+	ret_list->items[n_ready++] = mp_obj_new_tuple(2, tuple);
+	if (self->flags & FLAG_ONESHOT) {
+	    // Don't poll next time, until new event flags will be set explicitly
+	    FD_CLR(fd, &self->rset);
+	    FD_CLR(fd, &self->wset);
+        }
+    }
+    return ret_list;
+}
+MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mpoll_poll_obj, 1, 3, poll_poll);
+
+STATIC mp_obj_t poll_ipoll(size_t n_args, const mp_obj_t *args) {
+    mp_obj_mpoll_t *self = MP_OBJ_TO_PTR(args[0]);
+
+    if (self->ret_tuple == MP_OBJ_NULL) {
+        self->ret_tuple = mp_obj_new_tuple(2, NULL);
+    }
+
+    MP_THREAD_GIL_EXIT();
+    if (poll_poll_internal(n_args, args) == 0)
+	self->iter_idx = CONFIG_LWIP_MAX_SOCKETS;
+    else
+	self->iter_idx = 0;
+    MP_THREAD_GIL_ENTER();
+
+    return args[0];
+}
+MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(mpoll_ipoll_obj, 1, 3, poll_ipoll);
+
+STATIC mp_obj_t poll_iternext(mp_obj_t self_in) {
+    mp_obj_mpoll_t *self = MP_OBJ_TO_PTR(self_in);
+
+    while (self->iter_idx < CONFIG_LWIP_MAX_SOCKETS) {
+	int i = self->iter_idx++;
+	if (self->socks[i] == NULL)
+	    continue;
+	int fd = i + LWIP_SOCKET_OFFSET;
+	int flags = 0;
+	if (FD_ISSET(fd, &self->rset_result))
+	    flags |= MP_STREAM_POLL_RD;
+	if (FD_ISSET(fd, &self->wset_result))
+	    flags |= MP_STREAM_POLL_WR;
+	if (flags == 0)
+	    continue;
+	mp_obj_tuple_t *t = MP_OBJ_TO_PTR(self->ret_tuple);
+	t->items[0] = MP_OBJ_FROM_PTR(self->socks[i]);
+	t->items[1] = MP_OBJ_NEW_SMALL_INT(flags);
+	if (self->flags & FLAG_ONESHOT) {
+	    // Don't poll next time, until new event flags will be set explicitly
+	    FD_CLR(fd, &self->rset);
+	    FD_CLR(fd, &self->wset);
+        }
+	return MP_OBJ_FROM_PTR(t);
+    }
+
+    return MP_OBJ_STOP_ITERATION;
+}
+
+STATIC const mp_rom_map_elem_t poll_locals_dict_table[] = {
+    { MP_ROM_QSTR(MP_QSTR_register), MP_ROM_PTR(&mpoll_register_obj) },
+    { MP_ROM_QSTR(MP_QSTR_unregister), MP_ROM_PTR(&mpoll_unregister_obj) },
+    { MP_ROM_QSTR(MP_QSTR_modify), MP_ROM_PTR(&mpoll_modify_obj) },
+    { MP_ROM_QSTR(MP_QSTR_poll), MP_ROM_PTR(&mpoll_poll_obj) },
+    { MP_ROM_QSTR(MP_QSTR_ipoll), MP_ROM_PTR(&mpoll_ipoll_obj) },
+};
+STATIC MP_DEFINE_CONST_DICT(poll_locals_dict, poll_locals_dict_table);
+
+STATIC const mp_obj_type_t mp_type_poll = {
+    { &mp_type_type },
+    .name = MP_QSTR_poll,
+    .getiter = mp_identity_getiter,
+    .iternext = poll_iternext,
+    .locals_dict = (void*)&poll_locals_dict,
+};
+
+/// \function poll()
+STATIC mp_obj_t mpoll_poll(void) {
+    mp_obj_mpoll_t *poll = m_new_obj(mp_obj_mpoll_t);
+    poll->base.type = &mp_type_poll;
+    poll->ret_tuple = MP_OBJ_NULL;
+    FD_ZERO(&poll->rset);
+    FD_ZERO(&poll->wset);
+    poll->maxfd = LWIP_SOCKET_OFFSET - 1;
+    for (int i = 0; i < CONFIG_LWIP_MAX_SOCKETS; i++)
+	poll->socks[i] = NULL;
+    return poll;
+}
+MP_DEFINE_CONST_FUN_OBJ_0(mp_mpoll_poll_obj, mpoll_poll);
+
+STATIC const mp_rom_map_elem_t mp_module_mpoll_globals_table[] = {
+    { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_mpoll) },
+    { MP_ROM_QSTR(MP_QSTR_poll), MP_ROM_PTR(&mp_mpoll_poll_obj) },
+    { MP_ROM_QSTR(MP_QSTR_POLLIN), MP_ROM_INT(MP_STREAM_POLL_RD) },
+    { MP_ROM_QSTR(MP_QSTR_POLLOUT), MP_ROM_INT(MP_STREAM_POLL_WR) },
+    { MP_ROM_QSTR(MP_QSTR_POLLERR), MP_ROM_INT(MP_STREAM_POLL_ERR) },
+    { MP_ROM_QSTR(MP_QSTR_POLLHUP), MP_ROM_INT(MP_STREAM_POLL_HUP) },
+};
+
+STATIC MP_DEFINE_CONST_DICT(mp_module_mpoll_globals, mp_module_mpoll_globals_table);
+
+const mp_obj_module_t mp_module_mpoll = {
+    .base = { &mp_type_module },
+    .globals = (mp_obj_dict_t*)&mp_module_mpoll_globals,
+};
+
+#endif // MICROPY_PY_MPOLL
diff --git a/ports/esp32/modsocket.c b/ports/esp32/modsocket.c
index 31d15396..2723d270 100644
--- a/ports/esp32/modsocket.c
+++ b/ports/esp32/modsocket.c
@@ -54,16 +54,10 @@
 #include "lwip/igmp.h"
 #include "esp_log.h"
 
-#define SOCKET_POLL_US (100000)
+#include "modsocket.h"
+#include "vterm.h"
 
-typedef struct _socket_obj_t {
-    mp_obj_base_t base;
-    int fd;
-    uint8_t domain;
-    uint8_t type;
-    uint8_t proto;
-    unsigned int retries;
-} socket_obj_t;
+#define SOCKET_POLL_US (100000)
 
 void _socket_settimeout(socket_obj_t *sock, uint64_t timeout_ms);
 
@@ -222,6 +216,16 @@ STATIC mp_obj_t socket_setsockopt(size_t n_args, const mp_obj_t *args) {
             break;
         }
 
+        // level: IPPROTO_TCP
+        case TCP_NODELAY: {
+            int val = mp_obj_get_int(args[3]);
+            int ret = lwip_setsockopt_r(self->fd, IPPROTO_TCP, opt, &val, sizeof(int));
+            if (ret != 0) {
+                exception_from_errno(errno);
+            }
+            break;
+        }
+
         // level: IPPROTO_IP
         case IP_ADD_MEMBERSHIP: {
             mp_buffer_info_t bufinfo;
@@ -392,6 +396,13 @@ STATIC mp_obj_t socket_makefile(size_t n_args, const mp_obj_t *args) {
 }
 STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(socket_makefile_obj, 1, 3, socket_makefile);
 
+STATIC mp_obj_t socket_airterm(mp_obj_t self_in) {
+    socket_obj_t *sock = MP_OBJ_TO_PTR(self_in);
+    bool ret = mp_vterm_register_airterm(sock->fd);
+    sock->fd = -1;
+    return ret ? mp_const_true : mp_const_false;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(socket_airterm_obj, socket_airterm);
 
 // XXX this can end up waiting a very long time if the content is dribbled in one character
 // at a time, as the timeout resets each time a recvfrom succeeds ... this is probably not
@@ -472,6 +483,7 @@ STATIC const mp_map_elem_t socket_locals_dict_table[] = {
     { MP_OBJ_NEW_QSTR(MP_QSTR_settimeout), (mp_obj_t)&socket_settimeout_obj },
     { MP_OBJ_NEW_QSTR(MP_QSTR_setblocking), (mp_obj_t)&socket_setblocking_obj },
     { MP_OBJ_NEW_QSTR(MP_QSTR_makefile), (mp_obj_t)&socket_makefile_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_airterm), (mp_obj_t)&socket_airterm_obj },
     { MP_OBJ_NEW_QSTR(MP_QSTR_fileno), (mp_obj_t)&socket_fileno_obj },
 
     { MP_OBJ_NEW_QSTR(MP_QSTR_read), (mp_obj_t)&mp_stream_read_obj },
@@ -584,6 +596,7 @@ STATIC const mp_map_elem_t mp_module_socket_globals_table[] = {
     { MP_OBJ_NEW_QSTR(MP_QSTR_SOL_SOCKET), MP_OBJ_NEW_SMALL_INT(SOL_SOCKET) },
     { MP_OBJ_NEW_QSTR(MP_QSTR_SO_REUSEADDR), MP_OBJ_NEW_SMALL_INT(SO_REUSEADDR) },
     { MP_OBJ_NEW_QSTR(MP_QSTR_IP_ADD_MEMBERSHIP), MP_OBJ_NEW_SMALL_INT(IP_ADD_MEMBERSHIP) },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_TCP_NODELAY), MP_OBJ_NEW_SMALL_INT(TCP_NODELAY) },
 };
 
 STATIC MP_DEFINE_CONST_DICT(mp_module_socket_globals, mp_module_socket_globals_table);
diff --git a/ports/esp32/modsocket.h b/ports/esp32/modsocket.h
new file mode 100644
index 00000000..13f57bce
--- /dev/null
+++ b/ports/esp32/modsocket.h
@@ -0,0 +1,39 @@
+/*
+ * This file is part of the MicroPython project, http://micropython.org/
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#ifndef INCLUDED_MODSOCKET_H
+#define INCLUDED_MODSOCKET_H
+
+#include "py/obj.h"
+#include "lwip/sockets.h"
+
+typedef struct _socket_obj_t {
+    mp_obj_base_t base;
+    int fd;
+    uint8_t domain;
+    uint8_t type;
+    uint8_t proto;
+    unsigned int retries;
+} socket_obj_t;
+
+#endif // INCLUDED_MODSOCKET_H
+
diff --git a/ports/esp32/modules/webrepl.py b/ports/esp32/modules/webrepl.py
new file mode 100644
index 00000000..ee11312b
--- /dev/null
+++ b/ports/esp32/modules/webrepl.py
@@ -0,0 +1,97 @@
+# This module should be imported from REPL, not run from command line.
+import sys
+import socket
+import uos
+import network
+import websocket
+import websocket_helper
+import _webrepl
+import machine
+
+listen_s = None
+client_s = None
+timer = None
+
+def setup_conn(port, accept_handler):
+    global listen_s
+    listen_s = socket.socket()
+    listen_s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
+
+    ai = socket.getaddrinfo("0.0.0.0", port)
+    addr = ai[0][4]
+
+    listen_s.bind(addr)
+    listen_s.listen(1)
+    if accept_handler:
+        listen_s.setblocking(False)
+        def manage(*args):
+            global client_s
+            try:
+                if client_s and client_s.fileno() == -1:
+                    client_s = None
+                    uos.dupterm(None)
+            except:
+                pass
+            try:
+                accept_conn(listen_s)
+            except:
+                pass
+        global timer
+        timer = machine.Timer(0)
+        timer.init(period=2000, mode=1, callback=manage)
+    for i in (network.AP_IF, network.STA_IF):
+        iface = network.WLAN(i)
+        if iface.active():
+            print("WebREPL daemon started on ws://%s:%d" % (iface.ifconfig()[0], port))
+    return listen_s
+
+
+def accept_conn(listen_sock):
+    global client_s
+    cl, remote_addr = listen_sock.accept()
+    prev = uos.dupterm(None)
+    uos.dupterm(prev)
+    if prev:
+        print("\nConcurrent WebREPL connection from", remote_addr, "rejected")
+        cl.close()
+        return
+    print("\nWebREPL connection from:", remote_addr)
+    client_s = cl
+    websocket_helper.server_handshake(cl)
+    ws = websocket.websocket(cl, True)
+    ws = _webrepl._webrepl(ws)
+    cl.setblocking(False)
+    uos.dupterm(ws)
+
+
+def stop():
+    global listen_s, client_s
+    uos.dupterm(None)
+    if client_s:
+        client_s.close()
+    if listen_s:
+        listen_s.close()
+    if timer:
+        timer.deinit()
+
+
+def start(port=8266, password=None):
+    stop()
+    if password is None:
+        try:
+            import webrepl_cfg
+            _webrepl.password(webrepl_cfg.PASS)
+            setup_conn(port, accept_conn)
+            print("Started webrepl in normal mode")
+        except:
+            print("WebREPL is not configured, run 'import webrepl_setup'")
+    else:
+        _webrepl.password(password)
+        setup_conn(port, accept_conn)
+        print("Started webrepl in manual override mode")
+
+
+def start_foreground(port=8266):
+    stop()
+    s = setup_conn(port, None)
+    accept_conn(s)
diff --git a/ports/esp32/modules/webrepl_setup.py b/ports/esp32/modules/webrepl_setup.py
new file mode 120000
index 00000000..999888bf
--- /dev/null
+++ b/ports/esp32/modules/webrepl_setup.py
@@ -0,0 +1 @@
+../../esp8266/modules/webrepl_setup.py
\ No newline at end of file
diff --git a/ports/esp32/modules/websocket_helper.py b/ports/esp32/modules/websocket_helper.py
new file mode 120000
index 00000000..4bcf3bcb
--- /dev/null
+++ b/ports/esp32/modules/websocket_helper.py
@@ -0,0 +1 @@
+../../esp8266/modules/websocket_helper.py
\ No newline at end of file
diff --git a/ports/esp32/moduos.c b/ports/esp32/moduos.c
index 9f0e291a..54f357a6 100644
--- a/ports/esp32/moduos.c
+++ b/ports/esp32/moduos.c
@@ -36,10 +36,13 @@
 #include "py/objstr.h"
 #include "py/runtime.h"
 #include "py/mperrno.h"
+#include "py/stream.h"
 #include "extmod/vfs.h"
 #include "extmod/vfs_fat.h"
 #include "genhdr/mpversion.h"
 
+#include "vterm.h"
+
 extern const mp_obj_type_t mp_fat_vfs_type;
 
 STATIC const qstr os_uname_info_fields[] = {
@@ -84,23 +87,30 @@ STATIC mp_obj_t os_urandom(mp_obj_t num) {
 }
 STATIC MP_DEFINE_CONST_FUN_OBJ_1(os_urandom_obj, os_urandom);
 
-#if MICROPY_PY_OS_DUPTERM
-STATIC mp_obj_t os_dupterm_notify(mp_obj_t obj_in) {
-    (void)obj_in;
-    mp_hal_signal_dupterm_input();
-    return mp_const_none;
+STATIC mp_obj_t os_dupterm(size_t n_args, const mp_obj_t *args) {
+    STATIC mp_obj_t prev_stream;
+    mp_obj_t ret_stream = prev_stream;
+    if (args[0] == mp_const_none) {
+	prev_stream = mp_const_none;
+    } else if (args[0] == prev_stream) {
+	;
+    } else {
+	if (mp_get_stream_raise(args[0], MP_STREAM_OP_READ|MP_STREAM_OP_WRITE) != 0) {
+	    prev_stream = args[0];
+	    mp_vterm_unregister();
+	    if (!mp_vterm_register_dupterm(prev_stream, 0))
+		mp_raise_OSError(MP_EINVAL);
+	}
+    }
+    return ret_stream;
 }
-STATIC MP_DEFINE_CONST_FUN_OBJ_1(os_dupterm_notify_obj, os_dupterm_notify);
-#endif
+STATIC MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(os_dupterm_obj, 1, 3, os_dupterm);
 
 STATIC const mp_rom_map_elem_t os_module_globals_table[] = {
     { MP_ROM_QSTR(MP_QSTR___name__), MP_ROM_QSTR(MP_QSTR_uos) },
     { MP_ROM_QSTR(MP_QSTR_uname), MP_ROM_PTR(&os_uname_obj) },
     { MP_ROM_QSTR(MP_QSTR_urandom), MP_ROM_PTR(&os_urandom_obj) },
-    #if MICROPY_PY_OS_DUPTERM
-    { MP_ROM_QSTR(MP_QSTR_dupterm), MP_ROM_PTR(&mp_uos_dupterm_obj) },
-    { MP_ROM_QSTR(MP_QSTR_dupterm_notify), MP_ROM_PTR(&os_dupterm_notify_obj) },
-    #endif
+    { MP_ROM_QSTR(MP_QSTR_dupterm), MP_ROM_PTR(&os_dupterm_obj) },
     #if MICROPY_VFS
     { MP_ROM_QSTR(MP_QSTR_ilistdir), MP_ROM_PTR(&mp_vfs_ilistdir_obj) },
     { MP_ROM_QSTR(MP_QSTR_listdir), MP_ROM_PTR(&mp_vfs_listdir_obj) },
diff --git a/ports/esp32/mpconfigport.h b/ports/esp32/mpconfigport.h
index 80594b11..dc18be14 100644
--- a/ports/esp32/mpconfigport.h
+++ b/ports/esp32/mpconfigport.h
@@ -141,7 +141,10 @@
 #define MICROPY_SSL_MBEDTLS                 (1)
 #define MICROPY_PY_USSL_FINALISER           (1)
 #define MICROPY_PY_WEBSOCKET                (1)
+#define MICROPY_PY_WEBREPL		    (1)
 #define MICROPY_PY_FRAMEBUF                 (1)
+#define MICROPY_PY_GENSTREAM		    (1)
+#define MICROPY_PY_MPOLL		    (1)
 
 // fatfs configuration
 #define MICROPY_FATFS_ENABLE_LFN            (1)
@@ -221,6 +224,7 @@ extern const struct _mp_obj_module_t mp_module_onewire;
 #define MICROPY_END_ATOMIC_SECTION(state) portEXIT_CRITICAL_NESTED(state)
 
 #if MICROPY_PY_THREAD
+extern void mp_handle_pending(void);
 #define MICROPY_EVENT_POLL_HOOK \
     do { \
         extern void mp_handle_pending(void); \
diff --git a/ports/esp32/mphalport.c b/ports/esp32/mphalport.c
index e588fc65..ddec5df9 100644
--- a/ports/esp32/mphalport.c
+++ b/ports/esp32/mphalport.c
@@ -27,6 +27,7 @@
  */
 
 #include <stdio.h>
+#include <string.h>
 #include <sys/time.h>
 
 #include "freertos/FreeRTOS.h"
@@ -39,49 +40,76 @@
 #include "extmod/misc.h"
 #include "lib/utils/pyexec.h"
 
-STATIC uint8_t stdin_ringbuf_array[256];
-ringbuf_t stdin_ringbuf = {stdin_ringbuf_array, sizeof(stdin_ringbuf_array)};
+static void noop_stdout_tx_strn(const char *str, uint32_t len)
+{
+}
+
+static void (*dup_stdout_tx_strn)(const char *str, uint32_t len) = noop_stdout_tx_strn;
+
+void mp_hal_stdout_dup(void (*tx_strn)(const char *str, uint32_t len))
+{
+    dup_stdout_tx_strn = tx_strn ? tx_strn : noop_stdout_tx_strn;
+}
 
 int mp_hal_stdin_rx_chr(void) {
+    MP_THREAD_GIL_EXIT();
     for (;;) {
-        int c = ringbuf_get(&stdin_ringbuf);
-        if (c != -1) {
+	size_t n;
+	unsigned char *p = xRingbufferReceiveUpTo(stdin_ringbuf, &n, 0, 1);
+	if (p) {
+	    int c = *p;
+	    vRingbufferReturnItem(stdin_ringbuf, p);
+	    MP_THREAD_GIL_ENTER();
             return c;
         }
-        MICROPY_EVENT_POLL_HOOK
-        vTaskDelay(1);
+	MP_THREAD_GIL_ENTER();
+	mp_handle_pending();
+	MP_THREAD_GIL_EXIT();
+        vTaskDelay(20/portTICK_PERIOD_MS);
     }
 }
 
+#define _stdout_tx_char_OUTOFGIL(c)	uart_tx_one_char(c)
+
 void mp_hal_stdout_tx_char(char c) {
+    MP_THREAD_GIL_EXIT();
+    dup_stdout_tx_strn(&c, 1);
     uart_tx_one_char(c);
-    //mp_uos_dupterm_tx_strn(&c, 1);
+    MP_THREAD_GIL_ENTER();
 }
 
 void mp_hal_stdout_tx_str(const char *str) {
     MP_THREAD_GIL_EXIT();
+    dup_stdout_tx_strn(str, strlen(str));
     while (*str) {
-        mp_hal_stdout_tx_char(*str++);
+        _stdout_tx_char_OUTOFGIL(*str++);
     }
     MP_THREAD_GIL_ENTER();
 }
 
 void mp_hal_stdout_tx_strn(const char *str, uint32_t len) {
     MP_THREAD_GIL_EXIT();
+    dup_stdout_tx_strn(str, len);
     while (len--) {
-        mp_hal_stdout_tx_char(*str++);
+        _stdout_tx_char_OUTOFGIL(*str++);
     }
     MP_THREAD_GIL_ENTER();
 }
 
 void mp_hal_stdout_tx_strn_cooked(const char *str, uint32_t len) {
+    const char *p = str;
+    const char cr = '\r';
     MP_THREAD_GIL_EXIT();
     while (len--) {
         if (*str == '\n') {
-            mp_hal_stdout_tx_char('\r');
+	    dup_stdout_tx_strn(p, str - p);
+	    dup_stdout_tx_strn(&cr, 1);
+	    p = str;
+            _stdout_tx_char_OUTOFGIL(cr);
         }
-        mp_hal_stdout_tx_char(*str++);
+        _stdout_tx_char_OUTOFGIL(*str++);
     }
+    dup_stdout_tx_strn(p, str - p);
     MP_THREAD_GIL_ENTER();
 }
 
diff --git a/ports/esp32/mphalport.h b/ports/esp32/mphalport.h
index 3215bc06..5650925f 100644
--- a/ports/esp32/mphalport.h
+++ b/ports/esp32/mphalport.h
@@ -29,10 +29,13 @@
 #ifndef INCLUDED_MPHALPORT_H
 #define INCLUDED_MPHALPORT_H
 
-#include "py/ringbuf.h"
 #include "lib/utils/interrupt_char.h"
+#include "freertos/ringbuf.h"
 
-extern ringbuf_t stdin_ringbuf;
+#define STDIN_RINGBUF_SIZE_b		(16)
+extern RingbufHandle_t stdin_ringbuf;
+
+void mp_hal_stdout_dup(void (*tx_strn)(const char *str, uint32_t len));
 
 uint32_t mp_hal_ticks_us(void);
 __attribute__((always_inline)) static inline uint32_t mp_hal_ticks_cpu(void) {
diff --git a/ports/esp32/mpthreadport.c b/ports/esp32/mpthreadport.c
index 76d9431c..b60049ff 100644
--- a/ports/esp32/mpthreadport.c
+++ b/ports/esp32/mpthreadport.c
@@ -37,8 +37,8 @@
 
 #if MICROPY_PY_THREAD
 
-#define MP_THREAD_MIN_STACK_SIZE                        (4 * 1024)
-#define MP_THREAD_DEFAULT_STACK_SIZE                    (MP_THREAD_MIN_STACK_SIZE + 1024)
+#define MP_THREAD_MIN_STACK_SIZE                        (1 * 1024)
+#define MP_THREAD_DEFAULT_STACK_SIZE                    (5 * 1024)
 #define MP_THREAD_PRIORITY                              (ESP_TASK_PRIO_MIN + 1)
 
 // this structure forms a linked list, one node per active thread
@@ -94,6 +94,11 @@ void mp_thread_set_state(void *state) {
     vTaskSetThreadLocalStoragePointer(NULL, 1, state);
 }
 
+bool mp_thread_is_main(void)
+{
+    return ((void *)mp_thread_get_state == (void *)&mp_state_ctx.thread);
+}
+
 void mp_thread_start(void) {
     mp_thread_mutex_lock(&thread_mutex, 1);
     for (thread_t *th = thread; th != NULL; th = th->next) {
diff --git a/ports/esp32/mpthreadport.h b/ports/esp32/mpthreadport.h
index 54e35d61..eebba304 100644
--- a/ports/esp32/mpthreadport.h
+++ b/ports/esp32/mpthreadport.h
@@ -39,6 +39,7 @@ typedef struct _mp_thread_mutex_t {
 } mp_thread_mutex_t;
 
 void mp_thread_init(void *stack, uint32_t stack_len);
+bool mp_thread_is_main(void);
 void mp_thread_gc_others(void);
 void mp_thread_deinit(void);
 
diff --git a/ports/esp32/sdkconfig.h b/ports/esp32/sdkconfig.h
index 113c0395..2bf86363 100644
--- a/ports/esp32/sdkconfig.h
+++ b/ports/esp32/sdkconfig.h
@@ -112,7 +112,7 @@
 #define CONFIG_LWIP_DHCPS_LEASE_UNIT 60
 #define CONFIG_LWIP_DHCPS_MAX_STATION_NUM 8
 #define CONFIG_LWIP_MAX_ACTIVE_TCP 16
-#define CONFIG_LWIP_MAX_SOCKETS 8
+#define CONFIG_LWIP_MAX_SOCKETS 12
 #define CONFIG_LWIP_SO_REUSE 1
 #define CONFIG_LWIP_ETHARP_TRUST_IP_MAC 1
 #define CONFIG_IP_LOST_TIMER_INTERVAL 120
diff --git a/ports/esp32/uart.c b/ports/esp32/uart.c
index 10a4ba46..ac66bf46 100644
--- a/ports/esp32/uart.c
+++ b/ports/esp32/uart.c
@@ -33,10 +33,13 @@
 #include "py/mpstate.h"
 #include "py/mphal.h"
 
+RingbufHandle_t stdin_ringbuf;
+
 STATIC void uart_irq_handler(void *arg);
 
 void uart_init(void) {
     uart_isr_handle_t handle;
+    stdin_ringbuf = xRingbufferCreate(STDIN_RINGBUF_SIZE_b, RINGBUF_TYPE_BYTEBUF);
     uart_isr_register(UART_NUM_0, uart_irq_handler, NULL, ESP_INTR_FLAG_LOWMED | ESP_INTR_FLAG_IRAM, &handle);
     uart_enable_rx_intr(UART_NUM_0);
 }
@@ -58,8 +61,8 @@ STATIC void IRAM_ATTR uart_irq_handler(void *arg) {
             }
             #endif
         } else {
-            // this is an inline function so will be in IRAM
-            ringbuf_put(&stdin_ringbuf, c);
+	    BaseType_t __dummy = pdFALSE;
+	    (void)xRingbufferSendFromISR(stdin_ringbuf, &c, sizeof(c), &__dummy);
         }
     }
 }
diff --git a/ports/esp32/vterm.c b/ports/esp32/vterm.c
new file mode 100644
index 00000000..1afaa7a2
--- /dev/null
+++ b/ports/esp32/vterm.c
@@ -0,0 +1,394 @@
+/*
+ * This file is part of the MicroPython project, http://micropython.org/
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "freertos/FreeRTOS.h"
+#include "freertos/semphr.h"
+#include "freertos/ringbuf.h"
+#include "esp_timer.h"
+#include "mphalport.h"
+#include "lwip/sockets.h"
+#include "py/nlr.h"
+#include "py/builtin.h"
+#include "py/runtime.h"
+#include "py/stream.h"
+#include "py/mpthread.h"
+
+#include "vterm.h"
+
+#define BUFSIZE_b 		128
+#define PUSH_WAIT_tick		(1000 / portTICK_PERIOD_MS)
+#define UNREG_WAIT_tick		(1000 / portTICK_PERIOD_MS)
+#define RINGBUF_WAIT_tick	( 500 / portTICK_PERIOD_MS)
+#define IO_INTERVAL_us		(20 * 1000)
+
+typedef struct _vterm_ops_t {
+    bool timered_read;
+    bool buffered_write;
+    ssize_t (*read)(void *vctx, void *buf, size_t n, bool in_gil);
+    ssize_t (*write)(void *vctx, const void *buf, size_t n, bool in_gil);
+    void (*unregister)(void *vctx);
+} _vterm_ops_t;
+
+typedef struct _vterm_t {
+    void *vctx;
+    bool timered_read;
+    bool buffered_write;
+    ssize_t (*read)(void *vctx, void *buf, size_t n, bool in_gil);
+    ssize_t (*write)(void *vctx, const void *buf, size_t n, bool in_gil);
+    void (*unregister)(void *vctx);
+    esp_timer_handle_t timer;
+    SemaphoreHandle_t mutex;
+    char s_buff[BUFSIZE_b];
+    size_t s_size;
+} _vterm_t;
+
+
+//----------------------------------------------------------------------------
+//----------------------------------------------------------------------------
+
+STATIC ssize_t _vterm_read_noop(void *vctx, void *buf, size_t n, bool in_gil)
+{
+    return -1;
+}
+
+STATIC ssize_t _vterm_write_noop(void *vctx, const void *buf, size_t n, bool in_gil)
+{
+    return -1;
+}
+
+STATIC void _vterm_unregister_noop(void *vctx)
+{
+}
+
+STATIC _vterm_t vterm = {
+    .read = _vterm_read_noop,
+    .write = _vterm_write_noop,
+    .unregister = _vterm_unregister_noop,
+};
+
+STATIC void _vterm_rx_chars(uint8_t *p, ssize_t n)
+{
+    for (; n--; p++) {
+	if (*p == mp_interrupt_char) {
+	    mp_keyboard_interrupt();
+	} else if (xRingbufferSend(stdin_ringbuf, p, 1, RINGBUF_WAIT_tick) != pdTRUE) {
+	    // drop input
+	}
+    }
+}
+
+STATIC void *__vterm_rx_thread(void *__in_gil)
+{
+    uint8_t buf[8];
+    bool in_gil = (bool)__in_gil;
+    for (;;) {
+	nlr_buf_t nlr;
+	if (nlr_push(&nlr) == 0) {
+	    ssize_t n = vterm.read(vterm.vctx, buf, sizeof(buf), in_gil);
+	    nlr_pop();
+	    if (n > 0)
+		_vterm_rx_chars(buf, n);
+	    else if (n == -1)
+		return 0;
+	}
+    }
+}
+
+STATIC mp_obj_t _vterm_rx_thread(void)
+{
+    (void)__vterm_rx_thread((void *)true);
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_0(_vterm_rx_thread_obj, _vterm_rx_thread);
+
+STATIC void _vterm_rx_timered(bool in_gil)
+{
+    uint8_t buf[8];
+    ssize_t n = vterm.read(vterm.vctx, buf, sizeof(buf), in_gil);
+    if (n > 0)
+	_vterm_rx_chars(buf, n);
+    else if (n != -2)		// NOT TIMEOUT
+	mp_vterm_unregister();
+}
+
+STATIC void _vterm_writeall(const char *data, uint32_t size, bool in_gil)
+{
+    while (size > 0) {
+	int n = vterm.write(vterm.vctx, data, size, in_gil);
+	if (n < 0) {
+	    mp_vterm_unregister();
+	    return;
+	}
+	data += n;
+	size -= n;
+    }
+}
+
+STATIC void mp_vterm_wr_direct(const char *data, uint32_t size)
+{
+    return _vterm_writeall(data, size, false);
+}
+
+STATIC void mp_vterm_wx_buffer(const char *data, uint32_t size)
+{
+    if (xSemaphoreTake(vterm.mutex, PUSH_WAIT_tick) == pdFALSE) {
+	return;
+    }
+    if (vterm.s_size + size > BUFSIZE_b) {
+	_vterm_writeall(vterm.s_buff, vterm.s_size, false);
+	_vterm_writeall(data, size, false);
+	vterm.s_size = 0;
+    } else {
+	(void)memcpy(&vterm.s_buff[vterm.s_size], data, size);
+	vterm.s_size += size;
+    }
+    xSemaphoreGive(vterm.mutex);
+}
+
+STATIC void _vterm_flush(bool in_gil)
+{
+    if (xSemaphoreTake(vterm.mutex, 0) == pdTRUE) {
+	if (vterm.s_size != 0) {
+	    _vterm_writeall(vterm.s_buff, vterm.s_size, in_gil);
+	    vterm.s_size = 0;
+	}
+	xSemaphoreGive(vterm.mutex);
+    }
+}
+
+STATIC void mp_vterm_timered_io(void *__arg)
+{
+    if (vterm.buffered_write)
+	_vterm_flush(false);
+    if (vterm.timered_read)
+	_vterm_rx_timered(false);
+}
+
+STATIC bool mp_vterm_register(void *vctx, const _vterm_ops_t *ops)
+{
+    vterm.vctx = vctx;
+    vterm.timered_read = ops->timered_read;
+    vterm.buffered_write = ops->buffered_write;
+    vterm.write = ops->write;
+    vterm.read = ops->read;
+    vterm.unregister = ops->unregister;
+    vterm.s_size = 0;
+
+    if (vterm.mutex == 0) {
+	return false;
+    }
+
+    if (vterm.buffered_write || vterm.timered_read) {
+	if (vterm.timer == 0) {
+	    return false;
+	}
+	if (esp_timer_start_periodic(vterm.timer, IO_INTERVAL_us) != ESP_OK) {
+	    esp_timer_delete(vterm.timer);
+	    vterm.timer = 0;
+	    return false;
+	}
+    }
+
+    if (!vterm.timered_read) {
+	mp_obj_t mod = MP_OBJ_FROM_PTR(&mp_module_thread);
+	mp_obj_t fun = mp_load_attr(mod, MP_QSTR_start_new_thread);
+	mp_obj_t trg = MP_OBJ_FROM_PTR(&_vterm_rx_thread_obj);
+	mp_obj_t args = mp_const_empty_tuple;
+	nlr_buf_t nlr;
+	if (nlr_push(&nlr) == 0) {
+	    mp_call_function_2(fun, trg, args);
+	    nlr_pop();
+	} else {
+	    if (vterm.buffered_write || vterm.timered_read)
+		esp_timer_stop(vterm.timer);
+	    return false;
+	}
+    }
+
+    if (vterm.buffered_write)
+	mp_hal_stdout_dup(mp_vterm_wx_buffer);
+    else
+	mp_hal_stdout_dup(mp_vterm_wr_direct);
+
+    return true;
+}
+
+void mp_vterm_unregister(void)
+{
+    if (vterm.buffered_write || vterm.timered_read)
+	esp_timer_stop(vterm.timer);
+
+    bool do_unlock = true;
+    if (xSemaphoreTake(vterm.mutex, UNREG_WAIT_tick) == pdFALSE) {
+	do_unlock = false;
+    }
+
+    void (*unregister)(void *vctx) = vterm.unregister;
+    vterm.read = _vterm_read_noop;
+    vterm.write = _vterm_write_noop;
+    vterm.unregister = _vterm_unregister_noop;
+    mp_hal_stdout_dup(0);
+    unregister(vterm.vctx);
+    vterm.s_size = 0;
+
+    if (do_unlock)
+	xSemaphoreGive(vterm.mutex);
+}
+
+void mp_vterm_init(void)
+{
+    if (vterm.mutex == 0) {
+	vterm.mutex = xSemaphoreCreateMutex();
+	esp_timer_create_args_t args = {
+	    .callback = mp_vterm_timered_io,
+	    .arg = 0,
+	    .dispatch_method = ESP_TIMER_TASK,
+	    .name = "airterm",
+	};
+	esp_timer_create(&args, &vterm.timer);
+    }
+}
+
+//----------------------------------------------------------------------------
+//             airterm - LWIP socket level terminal duplication
+//----------------------------------------------------------------------------
+
+typedef struct _airterm_ctx_t {
+    int socket;
+} _airterm_ctx_t;
+
+static _airterm_ctx_t airterm_ctx;
+
+STATIC ssize_t airterm_read(void *__vctx, void *buf, size_t n, bool in_gil)
+{
+    _airterm_ctx_t *ctx = __vctx;
+    ssize_t z = lwip_recvfrom_r(ctx->socket, buf, n, MSG_DONTWAIT, 0, 0);
+    if (z == -1 && errno == EWOULDBLOCK)
+	z = -2;
+    return z;
+}
+
+STATIC ssize_t airterm_write(void *__vctx, const void *buf, size_t n, bool in_gil)
+{
+    _airterm_ctx_t *ctx = __vctx;
+    if (in_gil)
+	MP_THREAD_GIL_EXIT();
+    ssize_t z = lwip_send_r(ctx->socket, buf, n, 0);
+    if (in_gil)
+	MP_THREAD_GIL_ENTER();
+    return z;
+}
+
+STATIC void airterm_unregister(void *__vctx)
+{
+    _airterm_ctx_t *ctx = __vctx;
+    if (ctx->socket != -1) {
+	lwip_close_r(ctx->socket);
+    }
+    ctx->socket = -1;
+}
+
+bool mp_vterm_register_airterm(int socket)
+{
+    //int enable = 1;
+    //lwip_setsockopt(socket, IPPROTO_TCP, TCP_NODELAY, &enable, sizeof(enable));
+    airterm_ctx.socket = socket;
+
+    _vterm_ops_t ops = {
+	.timered_read = true,
+	.buffered_write = true,
+	.read = airterm_read,
+	.write = airterm_write,
+	.unregister = airterm_unregister,
+    };
+
+    return mp_vterm_register(&airterm_ctx, &ops);
+}
+
+//----------------------------------------------------------------------------
+//              dupterm - altenative os.dupterm implementation
+//----------------------------------------------------------------------------
+
+typedef struct _dupterm_ctx_t {
+    mp_obj_t stream;
+} _dupterm_ctx_t;
+
+static _dupterm_ctx_t dupterm_ctx;
+
+STATIC ssize_t dupterm_read(void *__vctx, void *buf, size_t n, bool in_gil)
+{
+    _dupterm_ctx_t *ctx = __vctx;
+    int flag = MP_STREAM_RW_READ|MP_STREAM_RW_ONCE;
+    int errcode, z;
+    if (!in_gil)
+	MP_THREAD_GIL_ENTER();
+    for (;;) {
+	z = mp_stream_rw(ctx->stream, buf, 1, &errcode, flag);
+	if (errcode != MP_EWOULDBLOCK)
+	    break;
+        vTaskDelay(20/portTICK_PERIOD_MS);
+    }
+    if (!in_gil)
+	MP_THREAD_GIL_EXIT();
+    if (errcode == 0)
+	return z;
+    return -1;
+}
+
+STATIC ssize_t dupterm_write(void *__vctx, const void *buf, size_t n, bool in_gil)
+{
+    _dupterm_ctx_t *ctx = __vctx;
+    int errcode;
+    size_t z;
+    if (!in_gil)
+	MP_THREAD_GIL_ENTER();
+    z = mp_stream_rw(ctx->stream, (void *)buf, n, &errcode, MP_STREAM_RW_WRITE);
+    if (!in_gil)
+	MP_THREAD_GIL_EXIT();
+    if (errcode == 0)
+	return z;
+    return -1;
+}
+
+STATIC void dupterm_unregister(void *__vctx)
+{
+    _dupterm_ctx_t *ctx = __vctx;
+    (void)mp_stream_close(ctx->stream);
+    ctx->stream = 0;
+}
+
+bool mp_vterm_register_dupterm(mp_obj_t stream, int __stacksize_b)
+{
+    _vterm_ops_t ops = {
+	.timered_read = false,
+	.buffered_write = true,
+	.read = dupterm_read,
+	.write = dupterm_write,
+	.unregister = dupterm_unregister,
+    };
+    dupterm_ctx.stream = stream;
+    return mp_vterm_register(&dupterm_ctx, &ops);
+}
diff --git a/ports/esp32/vterm.h b/ports/esp32/vterm.h
new file mode 100644
index 00000000..c6416636
--- /dev/null
+++ b/ports/esp32/vterm.h
@@ -0,0 +1,31 @@
+/*
+ * This file is part of the MicroPython project, http://micropython.org/
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ * THE SOFTWARE.
+ */
+
+#ifndef INCLUDED_VTERM_H
+#define INCLUDED_VTERM_H
+
+void mp_vterm_init(void);
+bool mp_vterm_register_airterm(int socket);
+bool mp_vterm_register_dupterm(mp_obj_t stream, int stacksize_b);
+void mp_vterm_unregister(void);
+
+#endif // INCLUDED_VTERM_H
diff --git a/py/builtin.h b/py/builtin.h
index 84b99a8a..f2ada30d 100644
--- a/py/builtin.h
+++ b/py/builtin.h
@@ -115,6 +115,8 @@ extern const mp_obj_module_t mp_module_machine;
 extern const mp_obj_module_t mp_module_lwip;
 extern const mp_obj_module_t mp_module_websocket;
 extern const mp_obj_module_t mp_module_webrepl;
+extern const mp_obj_module_t mp_module_genstream;
+extern const mp_obj_module_t mp_module_mpoll;
 extern const mp_obj_module_t mp_module_framebuf;
 extern const mp_obj_module_t mp_module_btree;
 
diff --git a/py/mpconfig.h b/py/mpconfig.h
index 532b54ab..cf23f5b4 100644
--- a/py/mpconfig.h
+++ b/py/mpconfig.h
@@ -1182,6 +1182,10 @@ typedef double mp_float_t;
 #define MICROPY_PY_FRAMEBUF (0)
 #endif
 
+#ifndef MICROPY_PY_GENSTREAM
+#define MICROPY_PY_GENSTREAM (0)
+#endif
+
 #ifndef MICROPY_PY_BTREE
 #define MICROPY_PY_BTREE (0)
 #endif
diff --git a/py/objmodule.c b/py/objmodule.c
index c4aba3a7..f568cf66 100644
--- a/py/objmodule.c
+++ b/py/objmodule.c
@@ -214,6 +214,12 @@ STATIC const mp_rom_map_elem_t mp_builtin_module_table[] = {
 #if MICROPY_PY_WEBREPL
     { MP_ROM_QSTR(MP_QSTR__webrepl), MP_ROM_PTR(&mp_module_webrepl) },
 #endif
+#if MICROPY_PY_GENSTREAM
+    { MP_ROM_QSTR(MP_QSTR_genstream), MP_ROM_PTR(&mp_module_genstream) },
+#endif
+#if MICROPY_PY_MPOLL
+    { MP_ROM_QSTR(MP_QSTR_mpoll), MP_ROM_PTR(&mp_module_mpoll) },
+#endif
 #if MICROPY_PY_FRAMEBUF
     { MP_ROM_QSTR(MP_QSTR_framebuf), MP_ROM_PTR(&mp_module_framebuf) },
 #endif
diff --git a/py/py.mk b/py/py.mk
index 7c4cf82d..a11ebce5 100644
--- a/py/py.mk
+++ b/py/py.mk
@@ -238,6 +238,7 @@ PY_EXTMOD_O_BASENAME = \
 	extmod/moduselect.o \
 	extmod/modwebsocket.o \
 	extmod/modwebrepl.o \
+	extmod/modgenstream.o \
 	extmod/modframebuf.o \
 	extmod/vfs.o \
 	extmod/vfs_reader.o \
